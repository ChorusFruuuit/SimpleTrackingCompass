DrawContext.class:

//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package net.minecraft.client.gui;

import com.mojang.blaze3d.pipeline.RenderPipeline;
import com.mojang.blaze3d.textures.GpuTextureView;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Collectors;
import net.fabricmc.api.EnvType;
import net.fabricmc.api.Environment;
import net.minecraft.block.WoodType;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.font.TextRenderer;
import net.minecraft.client.gl.RenderPipelines;
import net.minecraft.client.gui.render.state.ColoredQuadGuiElementRenderState;
import net.minecraft.client.gui.render.state.GuiRenderState;
import net.minecraft.client.gui.render.state.ItemGuiElementRenderState;
import net.minecraft.client.gui.render.state.TextGuiElementRenderState;
import net.minecraft.client.gui.render.state.TexturedQuadGuiElementRenderState;
import net.minecraft.client.gui.render.state.special.BannerResultGuiElementRenderState;
import net.minecraft.client.gui.render.state.special.BookModelGuiElementRenderState;
import net.minecraft.client.gui.render.state.special.EntityGuiElementRenderState;
import net.minecraft.client.gui.render.state.special.PlayerSkinGuiElementRenderState;
import net.minecraft.client.gui.render.state.special.ProfilerChartGuiElementRenderState;
import net.minecraft.client.gui.render.state.special.SignGuiElementRenderState;
import net.minecraft.client.gui.screen.Screen;
import net.minecraft.client.gui.tooltip.HoveredTooltipPositioner;
import net.minecraft.client.gui.tooltip.TooltipBackgroundRenderer;
import net.minecraft.client.gui.tooltip.TooltipComponent;
import net.minecraft.client.gui.tooltip.TooltipPositioner;
import net.minecraft.client.model.Model;
import net.minecraft.client.model.ModelPart;
import net.minecraft.client.network.ClientPlayerEntity;
import net.minecraft.client.render.MapRenderState;
import net.minecraft.client.render.entity.model.BookModel;
import net.minecraft.client.render.entity.model.PlayerEntityModel;
import net.minecraft.client.render.entity.state.EntityRenderState;
import net.minecraft.client.render.item.KeyedItemRenderState;
import net.minecraft.client.texture.GuiAtlasManager;
import net.minecraft.client.texture.Scaling;
import net.minecraft.client.texture.Sprite;
import net.minecraft.client.texture.TextureManager;
import net.minecraft.client.texture.TextureSetup;
import net.minecraft.component.DataComponentTypes;
import net.minecraft.component.type.BannerPatternsComponent;
import net.minecraft.entity.LivingEntity;
import net.minecraft.item.ItemDisplayContext;
import net.minecraft.item.ItemStack;
import net.minecraft.item.tooltip.TooltipData;
import net.minecraft.text.HoverEvent;
import net.minecraft.text.OrderedText;
import net.minecraft.text.StringVisitable;
import net.minecraft.text.Style;
import net.minecraft.text.Text;
import net.minecraft.util.DyeColor;
import net.minecraft.util.Identifier;
import net.minecraft.util.Language;
import net.minecraft.util.Util;
import net.minecraft.util.crash.CrashException;
import net.minecraft.util.crash.CrashReport;
import net.minecraft.util.crash.CrashReportSection;
import net.minecraft.util.math.ColorHelper;
import net.minecraft.util.math.MathHelper;
import net.minecraft.util.profiler.ProfilerTiming;
import net.minecraft.world.World;
import org.jetbrains.annotations.Nullable;
import org.joml.Matrix3x2f;
import org.joml.Matrix3x2fStack;
import org.joml.Quaternionf;
import org.joml.Vector2ic;
import org.joml.Vector3f;

@Environment(EnvType.CLIENT)
public class DrawContext {
    private static final int BACKGROUND_MARGIN = 2;
    private final MinecraftClient client;
    private final Matrix3x2fStack matrices;
    public final ScissorStack scissorStack;
    private final GuiAtlasManager guiAtlasManager;
    public final GuiRenderState state;
    @Nullable
    private Runnable tooltipDrawer;

    private DrawContext(MinecraftClient client, Matrix3x2fStack matrices, GuiRenderState state) {
        this.scissorStack = new ScissorStack();
        this.client = client;
        this.matrices = matrices;
        this.guiAtlasManager = client.getGuiAtlasManager();
        this.state = state;
    }

    public DrawContext(MinecraftClient client, GuiRenderState state) {
        this(client, new Matrix3x2fStack(16), state);
    }

    public int getScaledWindowWidth() {
        return this.client.getWindow().getScaledWidth();
    }

    public int getScaledWindowHeight() {
        return this.client.getWindow().getScaledHeight();
    }

    public void createNewRootLayer() {
        this.state.createNewRootLayer();
    }

    public void applyBlur() {
        this.state.applyBlur();
    }

    public Matrix3x2fStack getMatrices() {
        return this.matrices;
    }

    public void drawHorizontalLine(int x1, int x2, int y, int color) {
        if (x2 < x1) {
            int i = x1;
            x1 = x2;
            x2 = i;
        }

        this.fill(x1, y, x2 + 1, y + 1, color);
    }

    public void drawVerticalLine(int x, int y1, int y2, int color) {
        if (y2 < y1) {
            int i = y1;
            y1 = y2;
            y2 = i;
        }

        this.fill(x, y1 + 1, x + 1, y2, color);
    }

    public void enableScissor(int x1, int y1, int x2, int y2) {
        ScreenRect screenRect = (new ScreenRect(x1, y1, x2 - x1, y2 - y1)).transform(this.matrices);
        this.scissorStack.push(screenRect);
    }

    public void disableScissor() {
        this.scissorStack.pop();
    }

    public boolean scissorContains(int x, int y) {
        return this.scissorStack.contains(x, y);
    }

    public void fill(int x1, int y1, int x2, int y2, int color) {
        this.fill(RenderPipelines.GUI, x1, y1, x2, y2, color);
    }

    public void fill(RenderPipeline pipeline, int x1, int y1, int x2, int y2, int color) {
        if (x1 < x2) {
            int i = x1;
            x1 = x2;
            x2 = i;
        }

        if (y1 < y2) {
            int i = y1;
            y1 = y2;
            y2 = i;
        }

        this.fill(pipeline, TextureSetup.empty(), x1, y1, x2, y2, color, (Integer)null);
    }

    public void fillGradient(int startX, int startY, int endX, int endY, int colorStart, int colorEnd) {
        this.fill(RenderPipelines.GUI, TextureSetup.empty(), startX, startY, endX, endY, colorStart, colorEnd);
    }

    public void fill(RenderPipeline pipeline, TextureSetup textureSetup, int x1, int y1, int x2, int y2) {
        this.fill(pipeline, textureSetup, x1, y1, x2, y2, -1, (Integer)null);
    }

    private void fill(RenderPipeline pipeline, TextureSetup textureSetup, int x1, int y1, int x2, int y2, int color, @Nullable Integer color2) {
        this.state.addSimpleElement(new ColoredQuadGuiElementRenderState(pipeline, textureSetup, new Matrix3x2f(this.matrices), x1, y1, x2, y2, color, color2 != null ? color2 : color, this.scissorStack.peekLast()));
    }

    public void drawSelection(int x1, int y1, int x2, int y2) {
        this.fill(RenderPipelines.GUI_INVERT, x1, y1, x2, y2, -1);
        this.fill(RenderPipelines.GUI_TEXT_HIGHLIGHT, x1, y1, x2, y2, -16776961);
    }

    public void drawCenteredTextWithShadow(TextRenderer textRenderer, String text, int centerX, int y, int color) {
        this.drawTextWithShadow(textRenderer, text, centerX - textRenderer.getWidth(text) / 2, y, color);
    }

    public void drawCenteredTextWithShadow(TextRenderer textRenderer, Text text, int centerX, int y, int color) {
        OrderedText orderedText = text.asOrderedText();
        this.drawTextWithShadow(textRenderer, orderedText, centerX - textRenderer.getWidth(orderedText) / 2, y, color);
    }

    public void drawCenteredTextWithShadow(TextRenderer textRenderer, OrderedText text, int centerX, int y, int color) {
        this.drawTextWithShadow(textRenderer, text, centerX - textRenderer.getWidth(text) / 2, y, color);
    }

    public void drawTextWithShadow(TextRenderer textRenderer, @Nullable String text, int x, int y, int color) {
        this.drawText(textRenderer, text, x, y, color, true);
    }

    public void drawText(TextRenderer textRenderer, @Nullable String text, int x, int y, int color, boolean shadow) {
        if (text != null) {
            this.drawText(textRenderer, Language.getInstance().reorder(StringVisitable.plain(text)), x, y, color, shadow);
        }
    }

    public void drawTextWithShadow(TextRenderer textRenderer, OrderedText text, int x, int y, int color) {
        this.drawText(textRenderer, text, x, y, color, true);
    }

    public void drawText(TextRenderer textRenderer, OrderedText text, int x, int y, int color, boolean shadow) {
        if (ColorHelper.getAlpha(color) != 0) {
            this.state.addText(new TextGuiElementRenderState(textRenderer, text, new Matrix3x2f(this.matrices), x, y, color, 0, shadow, this.scissorStack.peekLast()));
        }
    }

    public void drawTextWithShadow(TextRenderer textRenderer, Text text, int x, int y, int color) {
        this.drawText(textRenderer, text, x, y, color, true);
    }

    public void drawText(TextRenderer textRenderer, Text text, int x, int y, int color, boolean shadow) {
        this.drawText(textRenderer, text.asOrderedText(), x, y, color, shadow);
    }

    public void drawWrappedTextWithShadow(TextRenderer textRenderer, StringVisitable text, int x, int y, int width, int color) {
        this.drawWrappedText(textRenderer, text, x, y, width, color, true);
    }

    public void drawWrappedText(TextRenderer textRenderer, StringVisitable text, int x, int y, int width, int color, boolean shadow) {
        for(OrderedText orderedText : textRenderer.wrapLines(text, width)) {
            this.drawText(textRenderer, orderedText, x, y, color, shadow);
            Objects.requireNonNull(textRenderer);
            y += 9;
        }

    }

    public void drawTextWithBackground(TextRenderer textRenderer, Text text, int x, int y, int width, int color) {
        int i = this.client.options.getTextBackgroundColor(0.0F);
        if (i != 0) {
            int j = 2;
            int var10001 = x - 2;
            int var10002 = y - 2;
            int var10003 = x + width + 2;
            Objects.requireNonNull(textRenderer);
            this.fill(var10001, var10002, var10003, y + 9 + 2, ColorHelper.mix(i, color));
        }

        this.drawText(textRenderer, text, x, y, color, true);
    }

    public void drawBorder(int x, int y, int width, int height, int color) {
        this.fill(x, y, x + width, y + 1, color);
        this.fill(x, y + height - 1, x + width, y + height, color);
        this.fill(x, y + 1, x + 1, y + height - 1, color);
        this.fill(x + width - 1, y + 1, x + width, y + height - 1, color);
    }

    public void drawGuiTexture(RenderPipeline pipeline, Identifier sprite, int x, int y, int width, int height) {
        this.drawGuiTexture(pipeline, sprite, x, y, width, height, -1);
    }

    public void drawGuiTexture(RenderPipeline pipeline, Identifier sprite, int x, int y, int width, int height, float alpha) {
        this.drawGuiTexture(pipeline, sprite, x, y, width, height, ColorHelper.withAlpha(alpha, -1));
    }

    public void drawGuiTexture(RenderPipeline pipeline, Identifier sprite, int x, int y, int width, int height, int color) {
        Sprite sprite2 = this.guiAtlasManager.getSprite(sprite);
        Scaling scaling = this.guiAtlasManager.getScaling(sprite2);
        if (scaling instanceof Scaling.Stretch) {
            this.drawSpriteStretched(pipeline, sprite2, x, y, width, height, color);
        } else if (scaling instanceof Scaling.Tile) {
            Scaling.Tile tile = (Scaling.Tile)scaling;
            this.drawSpriteTiled(pipeline, sprite2, x, y, width, height, 0, 0, tile.width(), tile.height(), tile.width(), tile.height(), color);
        } else if (scaling instanceof Scaling.NineSlice) {
            Scaling.NineSlice nineSlice = (Scaling.NineSlice)scaling;
            this.drawSpriteNineSliced(pipeline, sprite2, nineSlice, x, y, width, height, color);
        }

    }

    public void drawGuiTexture(RenderPipeline pipeline, Identifier sprite, int textureWidth, int textureHeight, int u, int v, int x, int y, int width, int height) {
        this.drawGuiTexture(pipeline, sprite, textureWidth, textureHeight, u, v, x, y, width, height, -1);
    }

    public void drawGuiTexture(RenderPipeline pipeline, Identifier sprite, int textureWidth, int textureHeight, int u, int v, int x, int y, int width, int height, int color) {
        Sprite sprite2 = this.guiAtlasManager.getSprite(sprite);
        Scaling scaling = this.guiAtlasManager.getScaling(sprite2);
        if (scaling instanceof Scaling.Stretch) {
            this.drawSpriteRegion(pipeline, sprite2, textureWidth, textureHeight, u, v, x, y, width, height, color);
        } else {
            this.enableScissor(x, y, x + width, y + height);
            this.drawGuiTexture(pipeline, sprite, x - u, y - v, textureWidth, textureHeight, color);
            this.disableScissor();
        }

    }

    public void drawSpriteStretched(RenderPipeline pipeline, Sprite sprite, int x, int y, int width, int height) {
        this.drawSpriteStretched(pipeline, sprite, x, y, width, height, -1);
    }

    public void drawSpriteStretched(RenderPipeline pipeline, Sprite sprite, int x, int y, int width, int height, int color) {
        if (width != 0 && height != 0) {
            this.drawTexturedQuad(pipeline, sprite.getAtlasId(), x, x + width, y, y + height, sprite.getMinU(), sprite.getMaxU(), sprite.getMinV(), sprite.getMaxV(), color);
        }
    }

    private void drawSpriteRegion(RenderPipeline pipeline, Sprite sprite, int textureWidth, int textureHeight, int u, int v, int x, int y, int width, int height, int color) {
        if (width != 0 && height != 0) {
            this.drawTexturedQuad(pipeline, sprite.getAtlasId(), x, x + width, y, y + height, sprite.getFrameU((float)u / (float)textureWidth), sprite.getFrameU((float)(u + width) / (float)textureWidth), sprite.getFrameV((float)v / (float)textureHeight), sprite.getFrameV((float)(v + height) / (float)textureHeight), color);
        }
    }

    private void drawSpriteNineSliced(RenderPipeline pipeline, Sprite sprite, Scaling.NineSlice nineSlice, int x, int y, int width, int height, int color) {
        Scaling.NineSlice.Border border = nineSlice.border();
        int i = Math.min(border.left(), width / 2);
        int j = Math.min(border.right(), width / 2);
        int k = Math.min(border.top(), height / 2);
        int l = Math.min(border.bottom(), height / 2);
        if (width == nineSlice.width() && height == nineSlice.height()) {
            this.drawSpriteRegion(pipeline, sprite, nineSlice.width(), nineSlice.height(), 0, 0, x, y, width, height, color);
        } else if (height == nineSlice.height()) {
            this.drawSpriteRegion(pipeline, sprite, nineSlice.width(), nineSlice.height(), 0, 0, x, y, i, height, color);
            this.drawInnerSprite(pipeline, nineSlice, sprite, x + i, y, width - j - i, height, i, 0, nineSlice.width() - j - i, nineSlice.height(), nineSlice.width(), nineSlice.height(), color);
            this.drawSpriteRegion(pipeline, sprite, nineSlice.width(), nineSlice.height(), nineSlice.width() - j, 0, x + width - j, y, j, height, color);
        } else if (width == nineSlice.width()) {
            this.drawSpriteRegion(pipeline, sprite, nineSlice.width(), nineSlice.height(), 0, 0, x, y, width, k, color);
            this.drawInnerSprite(pipeline, nineSlice, sprite, x, y + k, width, height - l - k, 0, k, nineSlice.width(), nineSlice.height() - l - k, nineSlice.width(), nineSlice.height(), color);
            this.drawSpriteRegion(pipeline, sprite, nineSlice.width(), nineSlice.height(), 0, nineSlice.height() - l, x, y + height - l, width, l, color);
        } else {
            this.drawSpriteRegion(pipeline, sprite, nineSlice.width(), nineSlice.height(), 0, 0, x, y, i, k, color);
            this.drawInnerSprite(pipeline, nineSlice, sprite, x + i, y, width - j - i, k, i, 0, nineSlice.width() - j - i, k, nineSlice.width(), nineSlice.height(), color);
            this.drawSpriteRegion(pipeline, sprite, nineSlice.width(), nineSlice.height(), nineSlice.width() - j, 0, x + width - j, y, j, k, color);
            this.drawSpriteRegion(pipeline, sprite, nineSlice.width(), nineSlice.height(), 0, nineSlice.height() - l, x, y + height - l, i, l, color);
            this.drawInnerSprite(pipeline, nineSlice, sprite, x + i, y + height - l, width - j - i, l, i, nineSlice.height() - l, nineSlice.width() - j - i, l, nineSlice.width(), nineSlice.height(), color);
            this.drawSpriteRegion(pipeline, sprite, nineSlice.width(), nineSlice.height(), nineSlice.width() - j, nineSlice.height() - l, x + width - j, y + height - l, j, l, color);
            this.drawInnerSprite(pipeline, nineSlice, sprite, x, y + k, i, height - l - k, 0, k, i, nineSlice.height() - l - k, nineSlice.width(), nineSlice.height(), color);
            this.drawInnerSprite(pipeline, nineSlice, sprite, x + i, y + k, width - j - i, height - l - k, i, k, nineSlice.width() - j - i, nineSlice.height() - l - k, nineSlice.width(), nineSlice.height(), color);
            this.drawInnerSprite(pipeline, nineSlice, sprite, x + width - j, y + k, j, height - l - k, nineSlice.width() - j, k, j, nineSlice.height() - l - k, nineSlice.width(), nineSlice.height(), color);
        }
    }

    private void drawInnerSprite(RenderPipeline pipeline, Scaling.NineSlice nineSlice, Sprite sprite, int x, int y, int width, int height, int u, int v, int tileWidth, int tileHeight, int textureWidth, int textureHeight, int color) {
        if (width > 0 && height > 0) {
            if (nineSlice.stretchInner()) {
                this.drawTexturedQuad(pipeline, sprite.getAtlasId(), x, x + width, y, y + height, sprite.getFrameU((float)u / (float)textureWidth), sprite.getFrameU((float)(u + tileWidth) / (float)textureWidth), sprite.getFrameV((float)v / (float)textureHeight), sprite.getFrameV((float)(v + tileHeight) / (float)textureHeight), color);
            } else {
                this.drawSpriteTiled(pipeline, sprite, x, y, width, height, u, v, tileWidth, tileHeight, textureWidth, textureHeight, color);
            }

        }
    }

    private void drawSpriteTiled(RenderPipeline pipeline, Sprite sprite, int x, int y, int width, int height, int u, int v, int tileWidth, int tileHeight, int textureWidth, int textureHeight, int color) {
        if (width > 0 && height > 0) {
            if (tileWidth > 0 && tileHeight > 0) {
                for(int i = 0; i < width; i += tileWidth) {
                    int j = Math.min(tileWidth, width - i);

                    for(int k = 0; k < height; k += tileHeight) {
                        int l = Math.min(tileHeight, height - k);
                        this.drawSpriteRegion(pipeline, sprite, textureWidth, textureHeight, u, v, x + i, y + k, j, l, color);
                    }
                }

            } else {
                throw new IllegalArgumentException("Tiled sprite texture size must be positive, got " + tileWidth + "x" + tileHeight);
            }
        }
    }

    public void drawTexture(RenderPipeline pipeline, Identifier sprite, int x, int y, float u, float v, int width, int height, int textureWidth, int textureHeight, int color) {
        this.drawTexture(pipeline, sprite, x, y, u, v, width, height, width, height, textureWidth, textureHeight, color);
    }

    public void drawTexture(RenderPipeline pipeline, Identifier sprite, int x, int y, float u, float v, int width, int height, int textureWidth, int textureHeight) {
        this.drawTexture(pipeline, sprite, x, y, u, v, width, height, width, height, textureWidth, textureHeight);
    }

    public void drawTexture(RenderPipeline pipeline, Identifier sprite, int x, int y, float u, float v, int width, int height, int regionWidth, int regionHeight, int textureWidth, int textureHeight) {
        this.drawTexture(pipeline, sprite, x, y, u, v, width, height, regionWidth, regionHeight, textureWidth, textureHeight, -1);
    }

    public void drawTexture(RenderPipeline pipeline, Identifier sprite, int x, int y, float u, float v, int width, int height, int regionWidth, int regionHeight, int textureWidth, int textureHeight, int color) {
        this.drawTexturedQuad(pipeline, sprite, x, x + width, y, y + height, (u + 0.0F) / (float)textureWidth, (u + (float)regionWidth) / (float)textureWidth, (v + 0.0F) / (float)textureHeight, (v + (float)regionHeight) / (float)textureHeight, color);
    }

    public void drawTexturedQuad(Identifier sprite, int x1, int y1, int x2, int y2, float u1, float u2, float v1, float v2) {
        this.drawTexturedQuad(RenderPipelines.GUI_TEXTURED, (Identifier)sprite, x1, x2, y1, y2, u1, u2, v1, v2, -1);
    }

    private void drawTexturedQuad(RenderPipeline pipeline, Identifier sprite, int x1, int x2, int y1, int y2, float u1, float u2, float v1, float v2, int color) {
        GpuTextureView gpuTextureView = this.client.getTextureManager().getTexture(sprite).getGlTextureView();
        this.drawTexturedQuad(pipeline, gpuTextureView, x1, y1, x2, y2, u1, u2, v1, v2, color);
    }

    private void drawTexturedQuad(RenderPipeline pipeline, GpuTextureView texture, int x1, int y1, int x2, int y2, float u1, float u2, float v1, float v2, int color) {
        this.state.addSimpleElement(new TexturedQuadGuiElementRenderState(pipeline, TextureSetup.withoutGlTexture(texture), new Matrix3x2f(this.matrices), x1, y1, x2, y2, u1, u2, v1, v2, color, this.scissorStack.peekLast()));
    }

    public void drawItem(ItemStack item, int x, int y) {
        this.drawItem(this.client.player, this.client.world, item, x, y, 0);
    }

    public void drawItem(ItemStack stack, int x, int y, int seed) {
        this.drawItem(this.client.player, this.client.world, stack, x, y, seed);
    }

    public void drawItemWithoutEntity(ItemStack stack, int x, int y) {
        this.drawItemWithoutEntity(stack, x, y, 0);
    }

    public void drawItemWithoutEntity(ItemStack stack, int x, int y, int seed) {
        this.drawItem((LivingEntity)null, this.client.world, stack, x, y, seed);
    }

    public void drawItem(LivingEntity entity, ItemStack stack, int x, int y, int seed) {
        this.drawItem(entity, entity.getWorld(), stack, x, y, seed);
    }

    private void drawItem(@Nullable LivingEntity entity, @Nullable World world, ItemStack stack, int x, int y, int seed) {
        if (!stack.isEmpty()) {
            KeyedItemRenderState keyedItemRenderState = new KeyedItemRenderState();
            this.client.getItemModelManager().clearAndUpdate(keyedItemRenderState, stack, ItemDisplayContext.GUI, world, entity, seed);

            try {
                this.state.addItem(new ItemGuiElementRenderState(stack.getItem().getName().toString(), new Matrix3x2f(this.matrices), keyedItemRenderState, x, y, this.scissorStack.peekLast()));
            } catch (Throwable throwable) {
                CrashReport crashReport = CrashReport.create(throwable, "Rendering item");
                CrashReportSection crashReportSection = crashReport.addElement("Item being rendered");
                crashReportSection.add("Item Type", () -> String.valueOf(stack.getItem()));
                crashReportSection.add("Item Components", () -> String.valueOf(stack.getComponents()));
                crashReportSection.add("Item Foil", () -> String.valueOf(stack.hasGlint()));
                throw new CrashException(crashReport);
            }
        }
    }

    public void drawStackOverlay(TextRenderer textRenderer, ItemStack stack, int x, int y) {
        this.drawStackOverlay(textRenderer, stack, x, y, (String)null);
    }

    public void drawStackOverlay(TextRenderer textRenderer, ItemStack stack, int x, int y, @Nullable String stackCountText) {
        if (!stack.isEmpty()) {
            this.matrices.pushMatrix();
            this.drawItemBar(stack, x, y);
            this.drawCooldownProgress(stack, x, y);
            this.drawStackCount(textRenderer, stack, x, y, stackCountText);
            this.matrices.popMatrix();
        }
    }

    public void drawTooltip(Text text, int x, int y) {
        this.drawTooltip(List.of(text.asOrderedText()), x, y);
    }

    public void drawTooltip(List<OrderedText> text, int x, int y) {
        this.drawTooltip(this.client.textRenderer, text, HoveredTooltipPositioner.INSTANCE, x, y, false);
    }

    public void drawItemTooltip(TextRenderer textRenderer, ItemStack stack, int x, int y) {
        this.drawTooltip(textRenderer, Screen.getTooltipFromItem(this.client, stack), stack.getTooltipData(), x, y, (Identifier)stack.get(DataComponentTypes.TOOLTIP_STYLE));
    }

    public void drawTooltip(TextRenderer textRenderer, List<Text> text, Optional<TooltipData> data, int x, int y) {
        this.drawTooltip(textRenderer, text, data, x, y, (Identifier)null);
    }

    public void drawTooltip(TextRenderer textRenderer, List<Text> text, Optional<TooltipData> data, int x, int y, @Nullable Identifier texture) {
        List<TooltipComponent> list = (List)text.stream().map(Text::asOrderedText).map(TooltipComponent::of).collect(Util.toArrayList());
        data.ifPresent((datax) -> list.add(list.isEmpty() ? 0 : 1, TooltipComponent.of(datax)));
        this.drawTooltip(textRenderer, list, x, y, HoveredTooltipPositioner.INSTANCE, texture, false);
    }

    public void drawTooltip(TextRenderer textRenderer, Text text, int x, int y) {
        this.drawTooltip(textRenderer, text, x, y, (Identifier)null);
    }

    public void drawTooltip(TextRenderer textRenderer, Text text, int x, int y, @Nullable Identifier texture) {
        this.drawOrderedTooltip(textRenderer, List.of(text.asOrderedText()), x, y, texture);
    }

    public void drawTooltip(TextRenderer textRenderer, List<Text> text, int x, int y) {
        this.drawTooltip(textRenderer, (List)text, x, y, (Identifier)null);
    }

    public void drawTooltip(TextRenderer textRenderer, List<Text> text, int x, int y, @Nullable Identifier texture) {
        this.drawTooltip(textRenderer, text.stream().map(Text::asOrderedText).map(TooltipComponent::of).toList(), x, y, HoveredTooltipPositioner.INSTANCE, texture, false);
    }

    public void drawOrderedTooltip(TextRenderer textRenderer, List<? extends OrderedText> text, int x, int y) {
        this.drawOrderedTooltip(textRenderer, text, x, y, (Identifier)null);
    }

    public void drawOrderedTooltip(TextRenderer textRenderer, List<? extends OrderedText> text, int x, int y, @Nullable Identifier texture) {
        this.drawTooltip(textRenderer, (List)text.stream().map(TooltipComponent::of).collect(Collectors.toList()), x, y, HoveredTooltipPositioner.INSTANCE, texture, false);
    }

    public void drawTooltip(TextRenderer textRenderer, List<OrderedText> text, TooltipPositioner positioner, int x, int y, boolean focused) {
        this.drawTooltip(textRenderer, (List)text.stream().map(TooltipComponent::of).collect(Collectors.toList()), x, y, positioner, (Identifier)null, focused);
    }

    private void drawTooltip(TextRenderer textRenderer, List<TooltipComponent> components, int x, int y, TooltipPositioner positioner, @Nullable Identifier texture, boolean focused) {
        if (!components.isEmpty()) {
            if (this.tooltipDrawer == null || focused) {
                this.tooltipDrawer = () -> this.drawTooltipImmediately(textRenderer, components, x, y, positioner, texture);
            }

        }
    }

    public void drawTooltipImmediately(TextRenderer textRenderer, List<TooltipComponent> components, int x, int y, TooltipPositioner positioner, @Nullable Identifier texture) {
        int i = 0;
        int j = components.size() == 1 ? -2 : 0;

        for(TooltipComponent tooltipComponent : components) {
            int k = tooltipComponent.getWidth(textRenderer);
            if (k > i) {
                i = k;
            }

            j += tooltipComponent.getHeight(textRenderer);
        }

        int l = i;
        int m = j;
        Vector2ic vector2ic = positioner.getPosition(this.getScaledWindowWidth(), this.getScaledWindowHeight(), x, y, i, j);
        int n = vector2ic.x();
        int o = vector2ic.y();
        this.matrices.pushMatrix();
        TooltipBackgroundRenderer.render(this, n, o, i, j, texture);
        int p = o;

        for(int q = 0; q < components.size(); ++q) {
            TooltipComponent tooltipComponent2 = (TooltipComponent)components.get(q);
            tooltipComponent2.drawText(this, textRenderer, n, p);
            p += tooltipComponent2.getHeight(textRenderer) + (q == 0 ? 2 : 0);
        }

        p = o;

        for(int q = 0; q < components.size(); ++q) {
            TooltipComponent tooltipComponent2 = (TooltipComponent)components.get(q);
            tooltipComponent2.drawItems(textRenderer, n, p, l, m, this);
            p += tooltipComponent2.getHeight(textRenderer) + (q == 0 ? 2 : 0);
        }

        this.matrices.popMatrix();
    }

    public void renderTooltip() {
        if (this.tooltipDrawer != null) {
            this.createNewRootLayer();
            this.tooltipDrawer.run();
            this.tooltipDrawer = null;
        }

    }

    private void drawItemBar(ItemStack stack, int x, int y) {
        if (stack.isItemBarVisible()) {
            int i = x + 2;
            int j = y + 13;
            this.fill(RenderPipelines.GUI, i, j, i + 13, j + 2, -16777216);
            this.fill(RenderPipelines.GUI, i, j, i + stack.getItemBarStep(), j + 1, ColorHelper.fullAlpha(stack.getItemBarColor()));
        }

    }

    private void drawStackCount(TextRenderer textRenderer, ItemStack stack, int x, int y, @Nullable String stackCountText) {
        if (stack.getCount() != 1 || stackCountText != null) {
            String string = stackCountText == null ? String.valueOf(stack.getCount()) : stackCountText;
            this.drawText(textRenderer, (String)string, x + 19 - 2 - textRenderer.getWidth(string), y + 6 + 3, -1, true);
        }

    }

    private void drawCooldownProgress(ItemStack stack, int x, int y) {
        ClientPlayerEntity clientPlayerEntity = this.client.player;
        float f = clientPlayerEntity == null ? 0.0F : clientPlayerEntity.getItemCooldownManager().getCooldownProgress(stack, this.client.getRenderTickCounter().getTickProgress(true));
        if (f > 0.0F) {
            int i = y + MathHelper.floor(16.0F * (1.0F - f));
            int j = i + MathHelper.ceil(16.0F * f);
            this.fill(RenderPipelines.GUI, x, i, x + 16, j, Integer.MAX_VALUE);
        }

    }

    public void drawHoverEvent(TextRenderer textRenderer, @Nullable Style style, int x, int y) {
        if (style != null && style.getHoverEvent() != null) {
            HoverEvent var10000 = style.getHoverEvent();
            Objects.requireNonNull(var10000);
            HoverEvent var5 = var10000;
            byte var6 = 0;
            //$FF: var6->value
            //0->net/minecraft/text/HoverEvent$ShowItem
            //1->net/minecraft/text/HoverEvent$ShowEntity
            //2->net/minecraft/text/HoverEvent$ShowText
            switch (var5.typeSwitch<invokedynamic>(var5, var6)) {
                case 0:
                    HoverEvent.ShowItem var7 = (HoverEvent.ShowItem)var5;
                    HoverEvent.ShowItem var23 = var7;

                    try {
                        var24 = var23.item();
                    } catch (Throwable var16) {
                        throw new MatchException(var16.toString(), var16);
                    }

                    ItemStack itemStack = var24;
                    this.drawItemTooltip(textRenderer, itemStack, x, y);
                    break;
                case 1:
                    HoverEvent.ShowEntity itemStack = (HoverEvent.ShowEntity)var5;
                    HoverEvent.ShowEntity var21 = itemStack;

                    try {
                        var22 = var21.entity();
                    } catch (Throwable var15) {
                        throw new MatchException(var15.toString(), var15);
                    }

                    HoverEvent.EntityContent entityContent = var22;
                    if (this.client.options.advancedItemTooltips) {
                        this.drawTooltip(textRenderer, entityContent.asTooltip(), x, y);
                    }
                    break;
                case 2:
                    HoverEvent.ShowText entityContent = (HoverEvent.ShowText)var5;
                    HoverEvent.ShowText var19 = entityContent;

                    try {
                        var20 = var19.value();
                    } catch (Throwable var14) {
                        throw new MatchException(var14.toString(), var14);
                    }

                    Text text = var20;
                    this.drawOrderedTooltip(textRenderer, textRenderer.wrapLines(text, Math.max(this.getScaledWindowWidth() / 2, 200)), x, y);
            }

        }
    }

    public void drawMap(MapRenderState mapState) {
        MinecraftClient minecraftClient = MinecraftClient.getInstance();
        TextureManager textureManager = minecraftClient.getTextureManager();
        GpuTextureView gpuTextureView = textureManager.getTexture(mapState.texture).getGlTextureView();
        this.drawTexturedQuad(RenderPipelines.GUI_TEXTURED, (GpuTextureView)gpuTextureView, 0, 0, 128, 128, 0.0F, 1.0F, 0.0F, 1.0F, -1);

        for(MapRenderState.Decoration decoration : mapState.decorations) {
            if (decoration.alwaysRendered) {
                this.matrices.pushMatrix();
                this.matrices.translate((float)decoration.x / 2.0F + 64.0F, (float)decoration.z / 2.0F + 64.0F);
                this.matrices.rotate(((float)Math.PI / 180F) * (float)decoration.rotation * 360.0F / 16.0F);
                this.matrices.scale(4.0F, 4.0F);
                this.matrices.translate(-0.125F, 0.125F);
                Sprite sprite = decoration.sprite;
                if (sprite != null) {
                    GpuTextureView gpuTextureView2 = textureManager.getTexture(sprite.getAtlasId()).getGlTextureView();
                    this.drawTexturedQuad(RenderPipelines.GUI_TEXTURED, (GpuTextureView)gpuTextureView2, -1, -1, 1, 1, sprite.getMinU(), sprite.getMaxU(), sprite.getMaxV(), sprite.getMinV(), -1);
                }

                this.matrices.popMatrix();
                if (decoration.name != null) {
                    TextRenderer textRenderer = minecraftClient.textRenderer;
                    float f = (float)textRenderer.getWidth(decoration.name);
                    float var10000 = 25.0F / f;
                    Objects.requireNonNull(textRenderer);
                    float g = MathHelper.clamp(var10000, 0.0F, 6.0F / 9.0F);
                    this.matrices.pushMatrix();
                    this.matrices.translate((float)decoration.x / 2.0F + 64.0F - f * g / 2.0F, (float)decoration.z / 2.0F + 64.0F + 4.0F);
                    this.matrices.scale(g, g);
                    this.state.addText(new TextGuiElementRenderState(textRenderer, decoration.name.asOrderedText(), new Matrix3x2f(this.matrices), 0, 0, -1, Integer.MIN_VALUE, false, this.scissorStack.peekLast()));
                    this.matrices.popMatrix();
                }
            }
        }

    }

    public void addEntity(EntityRenderState entityState, float scale, Vector3f translation, Quaternionf rotation, @Nullable Quaternionf overrideCameraAngle, int x1, int y1, int x2, int y2) {
        this.state.addSpecialElement(new EntityGuiElementRenderState(entityState, translation, rotation, overrideCameraAngle, x1, y1, x2, y2, scale, this.scissorStack.peekLast()));
    }

    public void addPlayerSkin(PlayerEntityModel playerModel, Identifier texture, float scale, float xRotation, float yRotation, float yPivot, int x1, int y1, int x2, int y2) {
        this.state.addSpecialElement(new PlayerSkinGuiElementRenderState(playerModel, texture, xRotation, yRotation, yPivot, x1, y1, x2, y2, scale, this.scissorStack.peekLast()));
    }

    public void addBookModel(BookModel bookModel, Identifier texture, float scale, float open, float flip, int x1, int y1, int x2, int y2) {
        this.state.addSpecialElement(new BookModelGuiElementRenderState(bookModel, texture, open, flip, x1, y1, x2, y2, scale, this.scissorStack.peekLast()));
    }

    public void addBannerResult(ModelPart flag, DyeColor baseColor, BannerPatternsComponent resultBannerPatterns, int x1, int y1, int x2, int y2) {
        this.state.addSpecialElement(new BannerResultGuiElementRenderState(flag, baseColor, resultBannerPatterns, x1, y1, x2, y2, this.scissorStack.peekLast()));
    }

    public void addSign(Model signModel, float scale, WoodType woodType, int x1, int y1, int x2, int y2) {
        this.state.addSpecialElement(new SignGuiElementRenderState(signModel, woodType, x1, y1, x2, y2, scale, this.scissorStack.peekLast()));
    }

    public void addProfilerChart(List<ProfilerTiming> chartData, int x1, int y1, int x2, int y2) {
        this.state.addSpecialElement(new ProfilerChartGuiElementRenderState(chartData, x1, y1, x2, y2, this.scissorStack.peekLast()));
    }

    @Environment(EnvType.CLIENT)
    public static class ScissorStack {
        private final Deque<ScreenRect> stack = new ArrayDeque();

        ScissorStack() {
        }

        public ScreenRect push(ScreenRect rect) {
            ScreenRect screenRect = (ScreenRect)this.stack.peekLast();
            if (screenRect != null) {
                ScreenRect screenRect2 = (ScreenRect)Objects.requireNonNullElse(rect.intersection(screenRect), ScreenRect.empty());
                this.stack.addLast(screenRect2);
                return screenRect2;
            } else {
                this.stack.addLast(rect);
                return rect;
            }
        }

        @Nullable
        public ScreenRect pop() {
            if (this.stack.isEmpty()) {
                throw new IllegalStateException("Scissor stack underflow");
            } else {
                this.stack.removeLast();
                return (ScreenRect)this.stack.peekLast();
            }
        }

        @Nullable
        public ScreenRect peekLast() {
            return (ScreenRect)this.stack.peekLast();
        }

        public boolean contains(int x, int y) {
            return this.stack.isEmpty() ? true : ((ScreenRect)this.stack.peek()).contains(x, y);
        }
    }
}

RenderPipeline.class:

//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package com.mojang.blaze3d.pipeline;

import com.mojang.blaze3d.platform.DepthTestFunction;
import com.mojang.blaze3d.platform.LogicOp;
import com.mojang.blaze3d.platform.PolygonMode;
import com.mojang.blaze3d.textures.TextureFormat;
import com.mojang.blaze3d.vertex.VertexFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import net.fabricmc.api.EnvType;
import net.fabricmc.api.Environment;
import net.minecraft.client.gl.Defines;
import net.minecraft.client.gl.UniformType;
import net.minecraft.util.Identifier;
import net.minecraft.util.annotation.DeobfuscateClass;
import org.jetbrains.annotations.Nullable;

@Environment(EnvType.CLIENT)
@DeobfuscateClass
public class RenderPipeline {
    private final Identifier location;
    private final Identifier vertexShader;
    private final Identifier fragmentShader;
    private final Defines shaderDefines;
    private final List<String> samplers;
    private final List<UniformDescription> uniforms;
    private final DepthTestFunction depthTestFunction;
    private final PolygonMode polygonMode;
    private final boolean cull;
    private final LogicOp colorLogic;
    private final Optional<BlendFunction> blendFunction;
    private final boolean writeColor;
    private final boolean writeAlpha;
    private final boolean writeDepth;
    private final VertexFormat vertexFormat;
    private final VertexFormat.DrawMode vertexFormatMode;
    private final float depthBiasScaleFactor;
    private final float depthBiasConstant;
    private final int sortKey;
    private static int sortKeySeed;

    protected RenderPipeline(Identifier location, Identifier vertexShader, Identifier fragmentShader, Defines shaderDefines, List<String> samplers, List<UniformDescription> uniforms, Optional<BlendFunction> blendFunction, DepthTestFunction depthTestFunction, PolygonMode polygonMode, boolean cull, boolean writeColor, boolean writeAlpha, boolean writeDepth, LogicOp colorLogic, VertexFormat vertexFormat, VertexFormat.DrawMode vertexFormatMode, float depthBiasScaleFactor, float depthBiasConstant, int sortKey) {
        this.location = location;
        this.vertexShader = vertexShader;
        this.fragmentShader = fragmentShader;
        this.shaderDefines = shaderDefines;
        this.samplers = samplers;
        this.uniforms = uniforms;
        this.depthTestFunction = depthTestFunction;
        this.polygonMode = polygonMode;
        this.cull = cull;
        this.blendFunction = blendFunction;
        this.writeColor = writeColor;
        this.writeAlpha = writeAlpha;
        this.writeDepth = writeDepth;
        this.colorLogic = colorLogic;
        this.vertexFormat = vertexFormat;
        this.vertexFormatMode = vertexFormatMode;
        this.depthBiasScaleFactor = depthBiasScaleFactor;
        this.depthBiasConstant = depthBiasConstant;
        this.sortKey = sortKey;
    }

    public int getSortKey() {
        return this.sortKey;
    }

    public static void updateSortKeySeed() {
        sortKeySeed = Math.round(100000.0F * (float)Math.random());
    }

    public String toString() {
        return this.location.toString();
    }

    public DepthTestFunction getDepthTestFunction() {
        return this.depthTestFunction;
    }

    public PolygonMode getPolygonMode() {
        return this.polygonMode;
    }

    public boolean isCull() {
        return this.cull;
    }

    public LogicOp getColorLogic() {
        return this.colorLogic;
    }

    public Optional<BlendFunction> getBlendFunction() {
        return this.blendFunction;
    }

    public boolean isWriteColor() {
        return this.writeColor;
    }

    public boolean isWriteAlpha() {
        return this.writeAlpha;
    }

    public boolean isWriteDepth() {
        return this.writeDepth;
    }

    public float getDepthBiasScaleFactor() {
        return this.depthBiasScaleFactor;
    }

    public float getDepthBiasConstant() {
        return this.depthBiasConstant;
    }

    public Identifier getLocation() {
        return this.location;
    }

    public VertexFormat getVertexFormat() {
        return this.vertexFormat;
    }

    public VertexFormat.DrawMode getVertexFormatMode() {
        return this.vertexFormatMode;
    }

    public Identifier getVertexShader() {
        return this.vertexShader;
    }

    public Identifier getFragmentShader() {
        return this.fragmentShader;
    }

    public Defines getShaderDefines() {
        return this.shaderDefines;
    }

    public List<String> getSamplers() {
        return this.samplers;
    }

    public List<UniformDescription> getUniforms() {
        return this.uniforms;
    }

    public boolean wantsDepthTexture() {
        return this.depthTestFunction != DepthTestFunction.NO_DEPTH_TEST || this.depthBiasConstant != 0.0F || this.depthBiasScaleFactor != 0.0F || this.writeDepth;
    }

    public static Builder builder(Snippet... snippets) {
        Builder builder = new Builder();

        for(Snippet snippet : snippets) {
            builder.withSnippet(snippet);
        }

        return builder;
    }

    @Environment(EnvType.CLIENT)
    @DeobfuscateClass
    public static class Builder {
        private static int nextPipelineSortKey;
        private Optional<Identifier> location = Optional.empty();
        private Optional<Identifier> fragmentShader = Optional.empty();
        private Optional<Identifier> vertexShader = Optional.empty();
        private Optional<Defines.Builder> definesBuilder = Optional.empty();
        private Optional<List<String>> samplers = Optional.empty();
        private Optional<List<UniformDescription>> uniforms = Optional.empty();
        private Optional<DepthTestFunction> depthTestFunction = Optional.empty();
        private Optional<PolygonMode> polygonMode = Optional.empty();
        private Optional<Boolean> cull = Optional.empty();
        private Optional<Boolean> writeColor = Optional.empty();
        private Optional<Boolean> writeAlpha = Optional.empty();
        private Optional<Boolean> writeDepth = Optional.empty();
        private Optional<LogicOp> colorLogic = Optional.empty();
        private Optional<BlendFunction> blendFunction = Optional.empty();
        private Optional<VertexFormat> vertexFormat = Optional.empty();
        private Optional<VertexFormat.DrawMode> vertexFormatMode = Optional.empty();
        private float depthBiasScaleFactor;
        private float depthBiasConstant;

        Builder() {
        }

        public Builder withLocation(String location) {
            this.location = Optional.of(Identifier.ofVanilla(location));
            return this;
        }

        public Builder withLocation(Identifier location) {
            this.location = Optional.of(location);
            return this;
        }

        public Builder withFragmentShader(String fragmentShader) {
            this.fragmentShader = Optional.of(Identifier.ofVanilla(fragmentShader));
            return this;
        }

        public Builder withFragmentShader(Identifier fragmentShader) {
            this.fragmentShader = Optional.of(fragmentShader);
            return this;
        }

        public Builder withVertexShader(String string) {
            this.vertexShader = Optional.of(Identifier.ofVanilla(string));
            return this;
        }

        public Builder withVertexShader(Identifier vertexShader) {
            this.vertexShader = Optional.of(vertexShader);
            return this;
        }

        public Builder withShaderDefine(String flag) {
            if (this.definesBuilder.isEmpty()) {
                this.definesBuilder = Optional.of(Defines.builder());
            }

            ((Defines.Builder)this.definesBuilder.get()).flag(flag);
            return this;
        }

        public Builder withShaderDefine(String name, int value) {
            if (this.definesBuilder.isEmpty()) {
                this.definesBuilder = Optional.of(Defines.builder());
            }

            ((Defines.Builder)this.definesBuilder.get()).define(name, value);
            return this;
        }

        public Builder withShaderDefine(String name, float value) {
            if (this.definesBuilder.isEmpty()) {
                this.definesBuilder = Optional.of(Defines.builder());
            }

            ((Defines.Builder)this.definesBuilder.get()).define(name, value);
            return this;
        }

        public Builder withSampler(String sampler) {
            if (this.samplers.isEmpty()) {
                this.samplers = Optional.of(new ArrayList());
            }

            ((List)this.samplers.get()).add(sampler);
            return this;
        }

        public Builder withUniform(String name, UniformType type) {
            if (this.uniforms.isEmpty()) {
                this.uniforms = Optional.of(new ArrayList());
            }

            if (type == UniformType.TEXEL_BUFFER) {
                throw new IllegalArgumentException("Cannot use texel buffer without specifying texture format");
            } else {
                ((List)this.uniforms.get()).add(new UniformDescription(name, type));
                return this;
            }
        }

        public Builder withUniform(String name, UniformType type, TextureFormat format) {
            if (this.uniforms.isEmpty()) {
                this.uniforms = Optional.of(new ArrayList());
            }

            if (type != UniformType.TEXEL_BUFFER) {
                throw new IllegalArgumentException("Only texel buffer can specify texture format");
            } else {
                ((List)this.uniforms.get()).add(new UniformDescription(name, format));
                return this;
            }
        }

        public Builder withDepthTestFunction(DepthTestFunction depthTestFunction) {
            this.depthTestFunction = Optional.of(depthTestFunction);
            return this;
        }

        public Builder withPolygonMode(PolygonMode polygonMode) {
            this.polygonMode = Optional.of(polygonMode);
            return this;
        }

        public Builder withCull(boolean cull) {
            this.cull = Optional.of(cull);
            return this;
        }

        public Builder withBlend(BlendFunction blendFunction) {
            this.blendFunction = Optional.of(blendFunction);
            return this;
        }

        public Builder withoutBlend() {
            this.blendFunction = Optional.empty();
            return this;
        }

        public Builder withColorWrite(boolean writeColor) {
            this.writeColor = Optional.of(writeColor);
            this.writeAlpha = Optional.of(writeColor);
            return this;
        }

        public Builder withColorWrite(boolean writeColor, boolean writeAlpha) {
            this.writeColor = Optional.of(writeColor);
            this.writeAlpha = Optional.of(writeAlpha);
            return this;
        }

        public Builder withDepthWrite(boolean writeDepth) {
            this.writeDepth = Optional.of(writeDepth);
            return this;
        }

        /** @deprecated */
        @Deprecated
        public Builder withColorLogic(LogicOp colorLogic) {
            this.colorLogic = Optional.of(colorLogic);
            return this;
        }

        public Builder withVertexFormat(VertexFormat vertexFormat, VertexFormat.DrawMode vertexFormatMode) {
            this.vertexFormat = Optional.of(vertexFormat);
            this.vertexFormatMode = Optional.of(vertexFormatMode);
            return this;
        }

        public Builder withDepthBias(float depthBiasScaleFactor, float depthBiasConstant) {
            this.depthBiasScaleFactor = depthBiasScaleFactor;
            this.depthBiasConstant = depthBiasConstant;
            return this;
        }

        void withSnippet(Snippet snippet) {
            if (snippet.vertexShader.isPresent()) {
                this.vertexShader = snippet.vertexShader;
            }

            if (snippet.fragmentShader.isPresent()) {
                this.fragmentShader = snippet.fragmentShader;
            }

            if (snippet.shaderDefines.isPresent()) {
                if (this.definesBuilder.isEmpty()) {
                    this.definesBuilder = Optional.of(Defines.builder());
                }

                Defines defines = (Defines)snippet.shaderDefines.get();

                for(Map.Entry<String, String> entry : defines.values().entrySet()) {
                    ((Defines.Builder)this.definesBuilder.get()).define((String)entry.getKey(), (String)entry.getValue());
                }

                for(String string : defines.flags()) {
                    ((Defines.Builder)this.definesBuilder.get()).flag(string);
                }
            }

            snippet.samplers.ifPresent((samplers) -> {
                if (this.samplers.isPresent()) {
                    ((List)this.samplers.get()).addAll(samplers);
                } else {
                    this.samplers = Optional.of(new ArrayList(samplers));
                }

            });
            snippet.uniforms.ifPresent((uniforms) -> {
                if (this.uniforms.isPresent()) {
                    ((List)this.uniforms.get()).addAll(uniforms);
                } else {
                    this.uniforms = Optional.of(new ArrayList(uniforms));
                }

            });
            if (snippet.depthTestFunction.isPresent()) {
                this.depthTestFunction = snippet.depthTestFunction;
            }

            if (snippet.cull.isPresent()) {
                this.cull = snippet.cull;
            }

            if (snippet.writeColor.isPresent()) {
                this.writeColor = snippet.writeColor;
            }

            if (snippet.writeAlpha.isPresent()) {
                this.writeAlpha = snippet.writeAlpha;
            }

            if (snippet.writeDepth.isPresent()) {
                this.writeDepth = snippet.writeDepth;
            }

            if (snippet.colorLogic.isPresent()) {
                this.colorLogic = snippet.colorLogic;
            }

            if (snippet.blendFunction.isPresent()) {
                this.blendFunction = snippet.blendFunction;
            }

            if (snippet.vertexFormat.isPresent()) {
                this.vertexFormat = snippet.vertexFormat;
            }

            if (snippet.vertexFormatMode.isPresent()) {
                this.vertexFormatMode = snippet.vertexFormatMode;
            }

        }

        public Snippet buildSnippet() {
            return new Snippet(this.vertexShader, this.fragmentShader, this.definesBuilder.map(Defines.Builder::build), this.samplers.map(Collections::unmodifiableList), this.uniforms.map(Collections::unmodifiableList), this.blendFunction, this.depthTestFunction, this.polygonMode, this.cull, this.writeColor, this.writeAlpha, this.writeDepth, this.colorLogic, this.vertexFormat, this.vertexFormatMode);
        }

        public RenderPipeline build() {
            if (this.location.isEmpty()) {
                throw new IllegalStateException("Missing location");
            } else if (this.vertexShader.isEmpty()) {
                throw new IllegalStateException("Missing vertex shader");
            } else if (this.fragmentShader.isEmpty()) {
                throw new IllegalStateException("Missing fragment shader");
            } else if (this.vertexFormat.isEmpty()) {
                throw new IllegalStateException("Missing vertex buffer format");
            } else if (this.vertexFormatMode.isEmpty()) {
                throw new IllegalStateException("Missing vertex mode");
            } else {
                return new RenderPipeline((Identifier)this.location.get(), (Identifier)this.vertexShader.get(), (Identifier)this.fragmentShader.get(), ((Defines.Builder)this.definesBuilder.orElse(Defines.builder())).build(), List.copyOf((Collection)this.samplers.orElse(new ArrayList())), (List)this.uniforms.orElse(Collections.emptyList()), this.blendFunction, (DepthTestFunction)this.depthTestFunction.orElse(DepthTestFunction.LEQUAL_DEPTH_TEST), (PolygonMode)this.polygonMode.orElse(PolygonMode.FILL), (Boolean)this.cull.orElse(true), (Boolean)this.writeColor.orElse(true), (Boolean)this.writeAlpha.orElse(true), (Boolean)this.writeDepth.orElse(true), (LogicOp)this.colorLogic.orElse(LogicOp.NONE), (VertexFormat)this.vertexFormat.get(), (VertexFormat.DrawMode)this.vertexFormatMode.get(), this.depthBiasScaleFactor, this.depthBiasConstant, nextPipelineSortKey++);
            }
        }
    }

    @Environment(EnvType.CLIENT)
    @DeobfuscateClass
    public static record UniformDescription(String name, UniformType type, @Nullable TextureFormat textureFormat) {
        public UniformDescription(String name, UniformType type) {
            this(name, type, (TextureFormat)null);
            if (type == UniformType.TEXEL_BUFFER) {
                throw new IllegalArgumentException("Texel buffer needs a texture format");
            }
        }

        public UniformDescription(String name, TextureFormat format) {
            this(name, UniformType.TEXEL_BUFFER, format);
        }
    }

    @Environment(EnvType.CLIENT)
    @DeobfuscateClass
    public static record Snippet(Optional<Identifier> vertexShader, Optional<Identifier> fragmentShader, Optional<Defines> shaderDefines, Optional<List<String>> samplers, Optional<List<UniformDescription>> uniforms, Optional<BlendFunction> blendFunction, Optional<DepthTestFunction> depthTestFunction, Optional<PolygonMode> polygonMode, Optional<Boolean> cull, Optional<Boolean> writeColor, Optional<Boolean> writeAlpha, Optional<Boolean> writeDepth, Optional<LogicOp> colorLogic, Optional<VertexFormat> vertexFormat, Optional<VertexFormat.DrawMode> vertexFormatMode) {
        final Optional<Identifier> vertexShader;
        final Optional<Identifier> fragmentShader;
        final Optional<Defines> shaderDefines;
        final Optional<List<String>> samplers;
        final Optional<List<UniformDescription>> uniforms;
        final Optional<BlendFunction> blendFunction;
        final Optional<DepthTestFunction> depthTestFunction;
        final Optional<Boolean> cull;
        final Optional<Boolean> writeColor;
        final Optional<Boolean> writeAlpha;
        final Optional<Boolean> writeDepth;
        final Optional<LogicOp> colorLogic;
        final Optional<VertexFormat> vertexFormat;
        final Optional<VertexFormat.DrawMode> vertexFormatMode;
    }
}

RenderPipelines.class:

//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package net.minecraft.client.gl;

import com.mojang.blaze3d.pipeline.BlendFunction;
import com.mojang.blaze3d.pipeline.RenderPipeline;
import com.mojang.blaze3d.platform.DepthTestFunction;
import com.mojang.blaze3d.platform.DestFactor;
import com.mojang.blaze3d.platform.PolygonMode;
import com.mojang.blaze3d.platform.SourceFactor;
import com.mojang.blaze3d.textures.TextureFormat;
import com.mojang.blaze3d.vertex.VertexFormat.DrawMode;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import net.fabricmc.api.EnvType;
import net.fabricmc.api.Environment;
import net.minecraft.client.render.VertexFormats;
import net.minecraft.util.Identifier;

@Environment(EnvType.CLIENT)
public class RenderPipelines {
    private static final Map<Identifier, RenderPipeline> PIPELINES = new HashMap();
    public static final RenderPipeline.Snippet TRANSFORMS_AND_PROJECTION_SNIPPET;
    public static final RenderPipeline.Snippet FOG_SNIPPET;
    public static final RenderPipeline.Snippet GLOBALS_SNIPPET;
    public static final RenderPipeline.Snippet TRANSFORMS_PROJECTION_FOG_SNIPPET;
    public static final RenderPipeline.Snippet TRANSFORMS_PROJECTION_FOG_LIGHTING_SNIPPET;
    public static final RenderPipeline.Snippet TERRAIN_SNIPPET;
    public static final RenderPipeline.Snippet ENTITY_SNIPPET;
    public static final RenderPipeline.Snippet ENTITY_EMISSIVE_SNIPPET;
    public static final RenderPipeline.Snippet RENDERTYPE_BEACON_BEAM_SNIPPET;
    public static final RenderPipeline.Snippet TEXT_SNIPPET;
    public static final RenderPipeline.Snippet RENDERTYPE_END_PORTAL_SNIPPET;
    public static final RenderPipeline.Snippet RENDERTYPE_CLOUDS_SNIPPET;
    public static final RenderPipeline.Snippet RENDERTYPE_LINES_SNIPPET;
    public static final RenderPipeline.Snippet POSITION_COLOR_SNIPPET;
    public static final RenderPipeline.Snippet PARTICLE_SNIPPET;
    public static final RenderPipeline.Snippet WEATHER_SNIPPET;
    public static final RenderPipeline.Snippet GUI_SNIPPET;
    public static final RenderPipeline.Snippet POSITION_TEX_COLOR_SNIPPET;
    public static final RenderPipeline.Snippet RENDERTYPE_OUTLINE_SNIPPET;
    public static final RenderPipeline.Snippet POST_EFFECT_PROCESSOR_SNIPPET;
    public static final RenderPipeline SOLID;
    public static final RenderPipeline WIREFRAME;
    public static final RenderPipeline CUTOUT_MIPPED;
    public static final RenderPipeline CUTOUT;
    public static final RenderPipeline TRANSLUCENT;
    public static final RenderPipeline TRIPWIRE;
    public static final RenderPipeline RENDERTYPE_TRANSLUCENT_MOVING_BLOCK;
    public static final RenderPipeline ARMOR_CUTOUT_NO_CULL;
    public static final RenderPipeline ARMOR_DECAL_CUTOUT_NO_CULL;
    public static final RenderPipeline ARMOR_TRANSLUCENT;
    public static final RenderPipeline ENTITY_SOLID;
    public static final RenderPipeline ENTITY_SOLID_OFFSET_FORWARD;
    public static final RenderPipeline ENTITY_CUTOUT;
    public static final RenderPipeline ENTITY_CUTOUT_NO_CULL;
    public static final RenderPipeline ENTITY_CUTOUT_NO_CULL_Z_OFFSET;
    public static final RenderPipeline ENTITY_TRANSLUCENT;
    public static final RenderPipeline ENTITY_TRANSLUCENT_EMISSIVE;
    public static final RenderPipeline ENTITY_SMOOTH_CUTOUT;
    public static final RenderPipeline ENTITY_NO_OUTLINE;
    public static final RenderPipeline BREEZE_WIND;
    public static final RenderPipeline ENTITY_ENERGY_SWIRL;
    public static final RenderPipeline ENTITY_EYES;
    public static final RenderPipeline RENDERTYPE_ENTITY_DECAL;
    public static final RenderPipeline RENDERTYPE_ENTITY_SHADOW;
    public static final RenderPipeline RENDERTYPE_ITEM_ENTITY_TRANSLUCENT_CULL;
    public static final RenderPipeline BEACON_BEAM_OPAQUE;
    public static final RenderPipeline BEACON_BEAM_TRANSLUCENT;
    public static final RenderPipeline RENDERTYPE_ENTITY_ALPHA;
    public static final RenderPipeline RENDERTYPE_LEASH;
    public static final RenderPipeline RENDERTYPE_WATER_MASK;
    public static final RenderPipeline GLINT;
    public static final RenderPipeline RENDERTYPE_CRUMBLING;
    public static final RenderPipeline RENDERTYPE_TEXT;
    public static final RenderPipeline RENDERTYPE_TEXT_BG;
    public static final RenderPipeline RENDERTYPE_TEXT_INTENSITY;
    public static final RenderPipeline RENDERTYPE_TEXT_POLYGON_OFFSET;
    public static final RenderPipeline RENDERTYPE_TEXT_SEETHROUGH;
    public static final RenderPipeline RENDERTYPE_TEXT_BG_SEETHROUGH;
    public static final RenderPipeline RENDERTYPE_TEXT_INTENSITY_SEETHROUGH;
    public static final RenderPipeline RENDERTYPE_LIGHTNING;
    public static final RenderPipeline RENDERTYPE_LIGHTNING_DRAGON_RAYS;
    public static final RenderPipeline POSITION_DRAGON_RAYS_DEPTH;
    public static final RenderPipeline END_PORTAL;
    public static final RenderPipeline END_GATEWAY;
    public static final RenderPipeline FLAT_CLOUDS;
    public static final RenderPipeline CLOUDS;
    public static final RenderPipeline LINES;
    public static final RenderPipeline SECOND_BLOCK_OUTLINE;
    public static final RenderPipeline LINE_STRIP;
    public static final RenderPipeline DEBUG_LINE_STRIP;
    public static final RenderPipeline DEBUG_FILLED_BOX;
    public static final RenderPipeline DEBUG_QUADS;
    public static final RenderPipeline DEBUG_TRIANGLE_FAN;
    public static final RenderPipeline DEBUG_STRUCTURE_QUADS;
    public static final RenderPipeline DEBUG_SECTION_QUADS;
    public static final RenderPipeline RENDERTYPE_WORLD_BORDER;
    public static final RenderPipeline OPAQUE_PARTICLE;
    public static final RenderPipeline TRANSLUCENT_PARTICLE;
    public static final RenderPipeline WEATHER_DEPTH;
    public static final RenderPipeline WEATHER_NO_DEPTH;
    public static final RenderPipeline POSITION_SKY;
    public static final RenderPipeline POSITION_TEX_COLOR_END_SKY;
    public static final RenderPipeline POSITION_COLOR_SUNRISE_SUNSET;
    public static final RenderPipeline POSITION_STARS;
    public static final RenderPipeline POSITION_TEX_COLOR_CELESTIAL;
    public static final RenderPipeline GUI;
    public static final RenderPipeline GUI_INVERT;
    public static final RenderPipeline GUI_TEXT_HIGHLIGHT;
    public static final RenderPipeline GUI_TEXTURED;
    public static final RenderPipeline GUI_TEXTURED_PREMULTIPLIED_ALPHA;
    public static final RenderPipeline BLOCK_SCREEN_EFFECT;
    public static final RenderPipeline FIRE_SCREEN_EFFECT;
    public static final RenderPipeline GUI_OPAQUE_TEX_BG;
    public static final RenderPipeline GUI_NAUSEA_OVERLAY;
    public static final RenderPipeline VIGNETTE;
    public static final RenderPipeline CROSSHAIR;
    public static final RenderPipeline MOJANG_LOGO;
    public static final RenderPipeline ENTITY_OUTLINE_BLIT;
    public static final RenderPipeline TRACY_BLIT;
    public static final RenderPipeline POSITION_TEX_PANORAMA;
    public static final RenderPipeline OUTLINE_CULL;
    public static final RenderPipeline OUTLINE_NO_CULL;
    public static final RenderPipeline BILT_SCREEN_LIGHTMAP;

    public static RenderPipeline register(RenderPipeline pipeline) {
        PIPELINES.put(pipeline.getLocation(), pipeline);
        return pipeline;
    }

    public static List<RenderPipeline> getAll() {
        return PIPELINES.values().stream().toList();
    }

    static {
        TRANSFORMS_AND_PROJECTION_SNIPPET = RenderPipeline.builder(new RenderPipeline.Snippet[0]).withUniform("DynamicTransforms", UniformType.UNIFORM_BUFFER).withUniform("Projection", UniformType.UNIFORM_BUFFER).buildSnippet();
        FOG_SNIPPET = RenderPipeline.builder(new RenderPipeline.Snippet[0]).withUniform("Fog", UniformType.UNIFORM_BUFFER).buildSnippet();
        GLOBALS_SNIPPET = RenderPipeline.builder(new RenderPipeline.Snippet[0]).withUniform("Globals", UniformType.UNIFORM_BUFFER).buildSnippet();
        TRANSFORMS_PROJECTION_FOG_SNIPPET = RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_AND_PROJECTION_SNIPPET, FOG_SNIPPET}).buildSnippet();
        TRANSFORMS_PROJECTION_FOG_LIGHTING_SNIPPET = RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_AND_PROJECTION_SNIPPET, FOG_SNIPPET}).withUniform("Lighting", UniformType.UNIFORM_BUFFER).buildSnippet();
        TERRAIN_SNIPPET = RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_PROJECTION_FOG_SNIPPET}).withVertexShader("core/terrain").withFragmentShader("core/terrain").withSampler("Sampler0").withSampler("Sampler2").withVertexFormat(VertexFormats.POSITION_COLOR_TEXTURE_LIGHT_NORMAL, DrawMode.QUADS).buildSnippet();
        ENTITY_SNIPPET = RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_PROJECTION_FOG_LIGHTING_SNIPPET}).withVertexShader("core/entity").withFragmentShader("core/entity").withSampler("Sampler0").withSampler("Sampler2").withVertexFormat(VertexFormats.POSITION_COLOR_TEXTURE_OVERLAY_LIGHT_NORMAL, DrawMode.QUADS).buildSnippet();
        ENTITY_EMISSIVE_SNIPPET = RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_PROJECTION_FOG_LIGHTING_SNIPPET}).withVertexShader("core/entity").withFragmentShader("core/entity").withSampler("Sampler0").withVertexFormat(VertexFormats.POSITION_COLOR_TEXTURE_OVERLAY_LIGHT_NORMAL, DrawMode.QUADS).withShaderDefine("EMISSIVE").buildSnippet();
        RENDERTYPE_BEACON_BEAM_SNIPPET = RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_PROJECTION_FOG_SNIPPET}).withVertexShader("core/rendertype_beacon_beam").withFragmentShader("core/rendertype_beacon_beam").withSampler("Sampler0").withVertexFormat(VertexFormats.POSITION_COLOR_TEXTURE_LIGHT_NORMAL, DrawMode.QUADS).buildSnippet();
        TEXT_SNIPPET = RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_AND_PROJECTION_SNIPPET}).withBlend(BlendFunction.TRANSLUCENT).withVertexFormat(VertexFormats.POSITION_COLOR_TEXTURE_LIGHT, DrawMode.QUADS).buildSnippet();
        RENDERTYPE_END_PORTAL_SNIPPET = RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_AND_PROJECTION_SNIPPET, FOG_SNIPPET, GLOBALS_SNIPPET}).withVertexShader("core/rendertype_end_portal").withFragmentShader("core/rendertype_end_portal").withSampler("Sampler0").withSampler("Sampler1").withVertexFormat(VertexFormats.POSITION, DrawMode.QUADS).buildSnippet();
        RENDERTYPE_CLOUDS_SNIPPET = RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_PROJECTION_FOG_SNIPPET}).withVertexShader("core/rendertype_clouds").withFragmentShader("core/rendertype_clouds").withBlend(BlendFunction.TRANSLUCENT).withVertexFormat(VertexFormats.EMPTY, DrawMode.QUADS).withUniform("CloudInfo", UniformType.UNIFORM_BUFFER).withUniform("CloudFaces", UniformType.TEXEL_BUFFER, TextureFormat.RED8I).buildSnippet();
        RENDERTYPE_LINES_SNIPPET = RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_PROJECTION_FOG_SNIPPET, GLOBALS_SNIPPET}).withVertexShader("core/rendertype_lines").withFragmentShader("core/rendertype_lines").withBlend(BlendFunction.TRANSLUCENT).withCull(false).withVertexFormat(VertexFormats.POSITION_COLOR_NORMAL, DrawMode.LINES).buildSnippet();
        POSITION_COLOR_SNIPPET = RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_AND_PROJECTION_SNIPPET}).withVertexShader("core/position_color").withFragmentShader("core/position_color").withBlend(BlendFunction.TRANSLUCENT).withVertexFormat(VertexFormats.POSITION_COLOR, DrawMode.QUADS).buildSnippet();
        PARTICLE_SNIPPET = RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_PROJECTION_FOG_SNIPPET}).withVertexShader("core/particle").withFragmentShader("core/particle").withSampler("Sampler0").withSampler("Sampler2").withVertexFormat(VertexFormats.POSITION_TEXTURE_COLOR_LIGHT, DrawMode.QUADS).buildSnippet();
        WEATHER_SNIPPET = RenderPipeline.builder(new RenderPipeline.Snippet[]{PARTICLE_SNIPPET}).withBlend(BlendFunction.TRANSLUCENT).withCull(false).buildSnippet();
        GUI_SNIPPET = RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_AND_PROJECTION_SNIPPET}).withVertexShader("core/gui").withFragmentShader("core/gui").withBlend(BlendFunction.TRANSLUCENT).withVertexFormat(VertexFormats.POSITION_COLOR, DrawMode.QUADS).buildSnippet();
        POSITION_TEX_COLOR_SNIPPET = RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_AND_PROJECTION_SNIPPET}).withVertexShader("core/position_tex_color").withFragmentShader("core/position_tex_color").withSampler("Sampler0").withBlend(BlendFunction.TRANSLUCENT).withVertexFormat(VertexFormats.POSITION_TEXTURE_COLOR, DrawMode.QUADS).buildSnippet();
        RENDERTYPE_OUTLINE_SNIPPET = RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_AND_PROJECTION_SNIPPET}).withVertexShader("core/rendertype_outline").withFragmentShader("core/rendertype_outline").withSampler("Sampler0").withDepthTestFunction(DepthTestFunction.NO_DEPTH_TEST).withDepthWrite(false).withVertexFormat(VertexFormats.POSITION_TEXTURE_COLOR, DrawMode.QUADS).buildSnippet();
        POST_EFFECT_PROCESSOR_SNIPPET = RenderPipeline.builder(new RenderPipeline.Snippet[0]).withDepthTestFunction(DepthTestFunction.NO_DEPTH_TEST).withDepthWrite(false).withVertexFormat(VertexFormats.POSITION, DrawMode.QUADS).withUniform("Projection", UniformType.UNIFORM_BUFFER).buildSnippet();
        SOLID = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{TERRAIN_SNIPPET}).withLocation("pipeline/solid").build());
        WIREFRAME = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{TERRAIN_SNIPPET}).withLocation("pipeline/wireframe").withPolygonMode(PolygonMode.WIREFRAME).build());
        CUTOUT_MIPPED = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{TERRAIN_SNIPPET}).withLocation("pipeline/cutout_mipped").withShaderDefine("ALPHA_CUTOUT", 0.5F).build());
        CUTOUT = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{TERRAIN_SNIPPET}).withLocation("pipeline/cutout").withShaderDefine("ALPHA_CUTOUT", 0.1F).build());
        TRANSLUCENT = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{TERRAIN_SNIPPET}).withLocation("pipeline/translucent").withBlend(BlendFunction.TRANSLUCENT).build());
        TRIPWIRE = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{TERRAIN_SNIPPET}).withLocation("pipeline/tripwire").withShaderDefine("ALPHA_CUTOUT", 0.1F).withBlend(BlendFunction.TRANSLUCENT).build());
        RENDERTYPE_TRANSLUCENT_MOVING_BLOCK = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_AND_PROJECTION_SNIPPET}).withLocation("pipeline/translucent_moving_block").withVertexShader("core/rendertype_translucent_moving_block").withFragmentShader("core/rendertype_translucent_moving_block").withSampler("Sampler0").withSampler("Sampler2").withBlend(BlendFunction.TRANSLUCENT).withVertexFormat(VertexFormats.POSITION_COLOR_TEXTURE_LIGHT_NORMAL, DrawMode.QUADS).build());
        ARMOR_CUTOUT_NO_CULL = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{ENTITY_SNIPPET}).withLocation("pipeline/armor_cutout_no_cull").withShaderDefine("ALPHA_CUTOUT", 0.1F).withShaderDefine("NO_OVERLAY").withCull(false).build());
        ARMOR_DECAL_CUTOUT_NO_CULL = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{ENTITY_SNIPPET}).withLocation("pipeline/armor_decal_cutout_no_cull").withShaderDefine("ALPHA_CUTOUT", 0.1F).withShaderDefine("NO_OVERLAY").withCull(false).withDepthTestFunction(DepthTestFunction.EQUAL_DEPTH_TEST).build());
        ARMOR_TRANSLUCENT = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{ENTITY_SNIPPET}).withLocation("pipeline/armor_translucent").withShaderDefine("ALPHA_CUTOUT", 0.1F).withShaderDefine("NO_OVERLAY").withBlend(BlendFunction.TRANSLUCENT).withCull(false).build());
        ENTITY_SOLID = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{ENTITY_SNIPPET}).withLocation("pipeline/entity_solid").withSampler("Sampler1").build());
        ENTITY_SOLID_OFFSET_FORWARD = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{ENTITY_SNIPPET}).withLocation("pipeline/entity_solid_offset_forward").withSampler("Sampler1").build());
        ENTITY_CUTOUT = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{ENTITY_SNIPPET}).withLocation("pipeline/entity_cutout").withShaderDefine("ALPHA_CUTOUT", 0.1F).withSampler("Sampler1").build());
        ENTITY_CUTOUT_NO_CULL = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{ENTITY_SNIPPET}).withLocation("pipeline/entity_cutout_no_cull").withShaderDefine("ALPHA_CUTOUT", 0.1F).withSampler("Sampler1").withCull(false).build());
        ENTITY_CUTOUT_NO_CULL_Z_OFFSET = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{ENTITY_SNIPPET}).withLocation("pipeline/entity_cutout_no_cull_z_offset").withShaderDefine("ALPHA_CUTOUT", 0.1F).withSampler("Sampler1").withCull(false).build());
        ENTITY_TRANSLUCENT = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{ENTITY_SNIPPET}).withLocation("pipeline/entity_translucent").withShaderDefine("ALPHA_CUTOUT", 0.1F).withSampler("Sampler1").withBlend(BlendFunction.TRANSLUCENT).withCull(false).build());
        ENTITY_TRANSLUCENT_EMISSIVE = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{ENTITY_EMISSIVE_SNIPPET}).withLocation("pipeline/entity_translucent_emissive").withShaderDefine("ALPHA_CUTOUT", 0.1F).withSampler("Sampler1").withBlend(BlendFunction.TRANSLUCENT).withCull(false).withDepthWrite(false).build());
        ENTITY_SMOOTH_CUTOUT = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{ENTITY_SNIPPET}).withLocation("pipeline/entity_smooth_cutout").withShaderDefine("ALPHA_CUTOUT", 0.1F).withSampler("Sampler1").withCull(false).build());
        ENTITY_NO_OUTLINE = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{ENTITY_SNIPPET}).withLocation("pipeline/entity_no_outline").withShaderDefine("NO_OVERLAY").withBlend(BlendFunction.TRANSLUCENT).withCull(false).withDepthWrite(false).build());
        BREEZE_WIND = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{ENTITY_SNIPPET}).withLocation("pipeline/breeze_wind").withShaderDefine("ALPHA_CUTOUT", 0.1F).withShaderDefine("APPLY_TEXTURE_MATRIX").withShaderDefine("NO_OVERLAY").withShaderDefine("NO_CARDINAL_LIGHTING").withBlend(BlendFunction.TRANSLUCENT).withCull(false).build());
        ENTITY_ENERGY_SWIRL = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_PROJECTION_FOG_SNIPPET}).withLocation("pipeline/energy_swirl").withVertexShader("core/entity").withFragmentShader("core/entity").withShaderDefine("ALPHA_CUTOUT", 0.1F).withShaderDefine("EMISSIVE").withShaderDefine("NO_OVERLAY").withShaderDefine("NO_CARDINAL_LIGHTING").withShaderDefine("APPLY_TEXTURE_MATRIX").withSampler("Sampler0").withBlend(BlendFunction.ADDITIVE).withCull(false).withVertexFormat(VertexFormats.POSITION_COLOR_TEXTURE_OVERLAY_LIGHT_NORMAL, DrawMode.QUADS).build());
        ENTITY_EYES = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_PROJECTION_FOG_SNIPPET}).withLocation("pipeline/eyes").withVertexShader("core/entity").withFragmentShader("core/entity").withShaderDefine("EMISSIVE").withShaderDefine("NO_OVERLAY").withShaderDefine("NO_CARDINAL_LIGHTING").withSampler("Sampler0").withBlend(BlendFunction.TRANSLUCENT).withDepthWrite(false).withVertexFormat(VertexFormats.POSITION_COLOR_TEXTURE_OVERLAY_LIGHT_NORMAL, DrawMode.QUADS).build());
        RENDERTYPE_ENTITY_DECAL = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_PROJECTION_FOG_LIGHTING_SNIPPET}).withLocation("pipeline/entity_decal").withVertexShader("core/rendertype_entity_decal").withFragmentShader("core/rendertype_entity_decal").withSampler("Sampler0").withSampler("Sampler1").withSampler("Sampler2").withDepthTestFunction(DepthTestFunction.EQUAL_DEPTH_TEST).withCull(false).withVertexFormat(VertexFormats.POSITION_COLOR_TEXTURE_OVERLAY_LIGHT_NORMAL, DrawMode.QUADS).build());
        RENDERTYPE_ENTITY_SHADOW = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_PROJECTION_FOG_SNIPPET}).withLocation("pipeline/entity_shadow").withVertexShader("core/rendertype_entity_shadow").withFragmentShader("core/rendertype_entity_shadow").withSampler("Sampler0").withBlend(BlendFunction.TRANSLUCENT).withDepthWrite(false).withVertexFormat(VertexFormats.POSITION_COLOR_TEXTURE_OVERLAY_LIGHT_NORMAL, DrawMode.QUADS).build());
        RENDERTYPE_ITEM_ENTITY_TRANSLUCENT_CULL = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_PROJECTION_FOG_LIGHTING_SNIPPET}).withLocation("pipeline/item_entity_translucent_cull").withVertexShader("core/rendertype_item_entity_translucent_cull").withFragmentShader("core/rendertype_item_entity_translucent_cull").withSampler("Sampler0").withSampler("Sampler2").withBlend(BlendFunction.TRANSLUCENT).withVertexFormat(VertexFormats.POSITION_COLOR_TEXTURE_OVERLAY_LIGHT_NORMAL, DrawMode.QUADS).build());
        BEACON_BEAM_OPAQUE = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{RENDERTYPE_BEACON_BEAM_SNIPPET}).withLocation("pipeline/beacon_beam_opaque").build());
        BEACON_BEAM_TRANSLUCENT = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{RENDERTYPE_BEACON_BEAM_SNIPPET}).withLocation("pipeline/beacon_beam_translucent").withDepthWrite(false).withBlend(BlendFunction.TRANSLUCENT).build());
        RENDERTYPE_ENTITY_ALPHA = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_AND_PROJECTION_SNIPPET}).withLocation("pipeline/dragon_explosion_alpha").withVertexShader("core/rendertype_entity_alpha").withFragmentShader("core/rendertype_entity_alpha").withSampler("Sampler0").withCull(false).withVertexFormat(VertexFormats.POSITION_COLOR_TEXTURE_OVERLAY_LIGHT_NORMAL, DrawMode.QUADS).build());
        RENDERTYPE_LEASH = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_PROJECTION_FOG_SNIPPET}).withLocation("pipeline/leash").withVertexShader("core/rendertype_leash").withFragmentShader("core/rendertype_leash").withSampler("Sampler2").withCull(false).withVertexFormat(VertexFormats.POSITION_COLOR_LIGHT, DrawMode.TRIANGLE_STRIP).build());
        RENDERTYPE_WATER_MASK = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_AND_PROJECTION_SNIPPET}).withLocation("pipeline/water_mask").withVertexShader("core/rendertype_water_mask").withFragmentShader("core/rendertype_water_mask").withColorWrite(false).withVertexFormat(VertexFormats.POSITION, DrawMode.QUADS).build());
        GLINT = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_AND_PROJECTION_SNIPPET, FOG_SNIPPET, GLOBALS_SNIPPET}).withLocation("pipeline/glint").withVertexShader("core/glint").withFragmentShader("core/glint").withSampler("Sampler0").withDepthWrite(false).withCull(false).withDepthTestFunction(DepthTestFunction.EQUAL_DEPTH_TEST).withBlend(BlendFunction.GLINT).withVertexFormat(VertexFormats.POSITION_TEXTURE, DrawMode.QUADS).build());
        RENDERTYPE_CRUMBLING = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_AND_PROJECTION_SNIPPET}).withLocation("pipeline/crumbling").withVertexShader("core/rendertype_crumbling").withFragmentShader("core/rendertype_crumbling").withSampler("Sampler0").withBlend(new BlendFunction(SourceFactor.DST_COLOR, DestFactor.SRC_COLOR, SourceFactor.ONE, DestFactor.ZERO)).withDepthWrite(false).withVertexFormat(VertexFormats.POSITION_COLOR_TEXTURE_LIGHT_NORMAL, DrawMode.QUADS).withDepthBias(-1.0F, -10.0F).build());
        RENDERTYPE_TEXT = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{TEXT_SNIPPET, FOG_SNIPPET}).withLocation("pipeline/text").withVertexShader("core/rendertype_text").withFragmentShader("core/rendertype_text").withSampler("Sampler0").withSampler("Sampler2").build());
        RENDERTYPE_TEXT_BG = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{TEXT_SNIPPET, FOG_SNIPPET}).withLocation("pipeline/text_background").withVertexShader("core/rendertype_text_background").withFragmentShader("core/rendertype_text_background").withSampler("Sampler2").withVertexFormat(VertexFormats.POSITION_COLOR_LIGHT, DrawMode.QUADS).build());
        RENDERTYPE_TEXT_INTENSITY = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{TEXT_SNIPPET, FOG_SNIPPET}).withLocation("pipeline/text_intensity").withVertexShader("core/rendertype_text_intensity").withFragmentShader("core/rendertype_text_intensity").withSampler("Sampler0").withSampler("Sampler2").withDepthBias(-1.0F, -10.0F).build());
        RENDERTYPE_TEXT_POLYGON_OFFSET = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{TEXT_SNIPPET, FOG_SNIPPET}).withLocation("pipeline/text_polygon_offset").withVertexShader("core/rendertype_text").withFragmentShader("core/rendertype_text").withSampler("Sampler0").withSampler("Sampler2").withDepthBias(-1.0F, -10.0F).build());
        RENDERTYPE_TEXT_SEETHROUGH = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{TEXT_SNIPPET}).withLocation("pipeline/text_see_through").withVertexShader("core/rendertype_text_see_through").withFragmentShader("core/rendertype_text_see_through").withSampler("Sampler0").withDepthWrite(false).withDepthTestFunction(DepthTestFunction.NO_DEPTH_TEST).build());
        RENDERTYPE_TEXT_BG_SEETHROUGH = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{TEXT_SNIPPET}).withLocation("pipeline/text_background_see_through").withVertexShader("core/rendertype_text_background_see_through").withFragmentShader("core/rendertype_text_background_see_through").withDepthWrite(false).withDepthTestFunction(DepthTestFunction.NO_DEPTH_TEST).withVertexFormat(VertexFormats.POSITION_COLOR_LIGHT, DrawMode.QUADS).build());
        RENDERTYPE_TEXT_INTENSITY_SEETHROUGH = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{TEXT_SNIPPET}).withLocation("pipeline/text_intensity_see_through").withVertexShader("core/rendertype_text_intensity_see_through").withFragmentShader("core/rendertype_text_intensity_see_through").withSampler("Sampler0").withDepthWrite(false).withDepthTestFunction(DepthTestFunction.NO_DEPTH_TEST).build());
        RENDERTYPE_LIGHTNING = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_PROJECTION_FOG_SNIPPET}).withLocation("pipeline/lightning").withVertexShader("core/rendertype_lightning").withFragmentShader("core/rendertype_lightning").withBlend(BlendFunction.LIGHTNING).withVertexFormat(VertexFormats.POSITION_COLOR, DrawMode.QUADS).build());
        RENDERTYPE_LIGHTNING_DRAGON_RAYS = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_PROJECTION_FOG_SNIPPET}).withLocation("pipeline/dragon_rays").withVertexShader("core/rendertype_lightning").withFragmentShader("core/rendertype_lightning").withDepthWrite(false).withBlend(BlendFunction.LIGHTNING).withVertexFormat(VertexFormats.POSITION_COLOR, DrawMode.TRIANGLES).build());
        POSITION_DRAGON_RAYS_DEPTH = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_PROJECTION_FOG_SNIPPET}).withLocation("pipeline/dragon_rays_depth").withVertexShader("core/position").withFragmentShader("core/position").withColorWrite(false).withVertexFormat(VertexFormats.POSITION, DrawMode.TRIANGLES).build());
        END_PORTAL = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{RENDERTYPE_END_PORTAL_SNIPPET}).withLocation("pipeline/end_portal").withShaderDefine("PORTAL_LAYERS", 15).build());
        END_GATEWAY = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{RENDERTYPE_END_PORTAL_SNIPPET}).withLocation("pipeline/end_gateway").withShaderDefine("PORTAL_LAYERS", 16).build());
        FLAT_CLOUDS = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{RENDERTYPE_CLOUDS_SNIPPET}).withLocation("pipeline/flat_clouds").withCull(false).build());
        CLOUDS = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{RENDERTYPE_CLOUDS_SNIPPET}).withLocation("pipeline/clouds").build());
        LINES = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{RENDERTYPE_LINES_SNIPPET}).withLocation("pipeline/lines").build());
        SECOND_BLOCK_OUTLINE = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{RENDERTYPE_LINES_SNIPPET}).withLocation("pipeline/secondary_block_outline").withDepthWrite(false).build());
        LINE_STRIP = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{RENDERTYPE_LINES_SNIPPET}).withLocation("pipeline/line_strip").withVertexFormat(VertexFormats.POSITION_COLOR_NORMAL, DrawMode.LINE_STRIP).build());
        DEBUG_LINE_STRIP = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_AND_PROJECTION_SNIPPET}).withLocation("pipeline/debug_line_strip").withVertexShader("core/position_color").withFragmentShader("core/position_color").withCull(false).withVertexFormat(VertexFormats.POSITION_COLOR, DrawMode.DEBUG_LINE_STRIP).build());
        DEBUG_FILLED_BOX = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{POSITION_COLOR_SNIPPET}).withLocation("pipeline/debug_filled_box").withVertexFormat(VertexFormats.POSITION_COLOR, DrawMode.TRIANGLE_STRIP).build());
        DEBUG_QUADS = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{POSITION_COLOR_SNIPPET}).withLocation("pipeline/debug_quads").withCull(false).build());
        DEBUG_TRIANGLE_FAN = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{POSITION_COLOR_SNIPPET}).withLocation("pipeline/debug_triangle_fan").withCull(false).withVertexFormat(VertexFormats.POSITION_COLOR, DrawMode.TRIANGLE_FAN).build());
        DEBUG_STRUCTURE_QUADS = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{POSITION_COLOR_SNIPPET}).withLocation("pipeline/debug_structure_quads").withCull(false).withDepthWrite(false).build());
        DEBUG_SECTION_QUADS = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{POSITION_COLOR_SNIPPET}).withLocation("pipeline/debug_section_quads").build());
        RENDERTYPE_WORLD_BORDER = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_AND_PROJECTION_SNIPPET}).withLocation("pipeline/world_border").withVertexShader("core/rendertype_world_border").withFragmentShader("core/rendertype_world_border").withSampler("Sampler0").withBlend(BlendFunction.OVERLAY).withCull(false).withVertexFormat(VertexFormats.POSITION_TEXTURE, DrawMode.QUADS).withDepthBias(-3.0F, -3.0F).build());
        OPAQUE_PARTICLE = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{PARTICLE_SNIPPET}).withLocation("pipeline/opaque_particle").build());
        TRANSLUCENT_PARTICLE = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{PARTICLE_SNIPPET}).withLocation("pipeline/translucent_particle").withBlend(BlendFunction.TRANSLUCENT).build());
        WEATHER_DEPTH = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{WEATHER_SNIPPET}).withLocation("pipeline/weather_depth_write").build());
        WEATHER_NO_DEPTH = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{WEATHER_SNIPPET}).withLocation("pipeline/weather_no_depth_write").withDepthWrite(false).build());
        POSITION_SKY = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_PROJECTION_FOG_SNIPPET}).withLocation("pipeline/sky").withVertexShader("core/sky").withFragmentShader("core/sky").withDepthWrite(false).withVertexFormat(VertexFormats.POSITION, DrawMode.TRIANGLE_FAN).build());
        POSITION_TEX_COLOR_END_SKY = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_AND_PROJECTION_SNIPPET}).withLocation("pipeline/end_sky").withVertexShader("core/position_tex_color").withFragmentShader("core/position_tex_color").withSampler("Sampler0").withBlend(BlendFunction.TRANSLUCENT).withDepthWrite(false).withVertexFormat(VertexFormats.POSITION_TEXTURE_COLOR, DrawMode.QUADS).build());
        POSITION_COLOR_SUNRISE_SUNSET = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_AND_PROJECTION_SNIPPET}).withLocation("pipeline/sunrise_sunset").withVertexShader("core/position_color").withFragmentShader("core/position_color").withBlend(BlendFunction.TRANSLUCENT).withDepthWrite(false).withVertexFormat(VertexFormats.POSITION_COLOR, DrawMode.TRIANGLE_FAN).build());
        POSITION_STARS = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_AND_PROJECTION_SNIPPET}).withLocation("pipeline/stars").withVertexShader("core/stars").withFragmentShader("core/stars").withBlend(BlendFunction.OVERLAY).withDepthWrite(false).withVertexFormat(VertexFormats.POSITION, DrawMode.QUADS).build());
        POSITION_TEX_COLOR_CELESTIAL = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_AND_PROJECTION_SNIPPET}).withLocation("pipeline/celestial").withVertexShader("core/position_tex_color").withFragmentShader("core/position_tex_color").withSampler("Sampler0").withBlend(BlendFunction.OVERLAY).withDepthWrite(false).withVertexFormat(VertexFormats.POSITION_TEXTURE_COLOR, DrawMode.QUADS).build());
        GUI = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{GUI_SNIPPET}).withLocation("pipeline/gui").build());
        GUI_INVERT = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{GUI_SNIPPET}).withLocation("pipeline/gui_invert").withBlend(BlendFunction.INVERT).build());
        GUI_TEXT_HIGHLIGHT = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{GUI_SNIPPET}).withLocation("pipeline/gui_text_highlight").withBlend(BlendFunction.ADDITIVE).build());
        GUI_TEXTURED = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{POSITION_TEX_COLOR_SNIPPET}).withLocation("pipeline/gui_textured").build());
        GUI_TEXTURED_PREMULTIPLIED_ALPHA = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{POSITION_TEX_COLOR_SNIPPET}).withLocation("pipeline/gui_textured_premultiplied_alpha").withBlend(BlendFunction.TRANSLUCENT_PREMULTIPLIED_ALPHA).build());
        BLOCK_SCREEN_EFFECT = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{POSITION_TEX_COLOR_SNIPPET}).withLocation("pipeline/block_screen_effect").withDepthTestFunction(DepthTestFunction.NO_DEPTH_TEST).withDepthWrite(false).build());
        FIRE_SCREEN_EFFECT = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{POSITION_TEX_COLOR_SNIPPET}).withLocation("pipeline/fire_screen_effect").withDepthTestFunction(DepthTestFunction.NO_DEPTH_TEST).withDepthWrite(false).build());
        GUI_OPAQUE_TEX_BG = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{POSITION_TEX_COLOR_SNIPPET}).withLocation("pipeline/gui_opaque_textured_background").withoutBlend().build());
        GUI_NAUSEA_OVERLAY = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{POSITION_TEX_COLOR_SNIPPET}).withLocation("pipeline/gui_nausea_overlay").withBlend(BlendFunction.ADDITIVE).build());
        VIGNETTE = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{POSITION_TEX_COLOR_SNIPPET}).withLocation("pipeline/vignette").withBlend(new BlendFunction(SourceFactor.ZERO, DestFactor.ONE_MINUS_SRC_COLOR)).build());
        CROSSHAIR = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{POSITION_TEX_COLOR_SNIPPET}).withLocation("pipeline/crosshair").withBlend(BlendFunction.INVERT).build());
        MOJANG_LOGO = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{POSITION_TEX_COLOR_SNIPPET}).withLocation("pipeline/mojang_logo").withBlend(new BlendFunction(SourceFactor.SRC_ALPHA, DestFactor.ONE)).build());
        ENTITY_OUTLINE_BLIT = register(RenderPipeline.builder(new RenderPipeline.Snippet[0]).withLocation("pipeline/entity_outline_blit").withVertexShader("core/blit_screen").withFragmentShader("core/blit_screen").withSampler("InSampler").withBlend(BlendFunction.ENTITY_OUTLINE_BLIT).withDepthWrite(false).withDepthTestFunction(DepthTestFunction.NO_DEPTH_TEST).withColorWrite(true, false).withVertexFormat(VertexFormats.POSITION, DrawMode.QUADS).build());
        TRACY_BLIT = register(RenderPipeline.builder(new RenderPipeline.Snippet[0]).withLocation("pipeline/tracy_blit").withVertexShader("core/blit_screen").withFragmentShader("core/blit_screen").withSampler("InSampler").withDepthWrite(false).withDepthTestFunction(DepthTestFunction.NO_DEPTH_TEST).withVertexFormat(VertexFormats.POSITION, DrawMode.QUADS).build());
        POSITION_TEX_PANORAMA = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{TRANSFORMS_AND_PROJECTION_SNIPPET}).withLocation("pipeline/panorama").withVertexShader("core/panorama").withFragmentShader("core/panorama").withSampler("Sampler0").withDepthWrite(false).withColorWrite(true, false).withVertexFormat(VertexFormats.POSITION, DrawMode.QUADS).build());
        OUTLINE_CULL = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{RENDERTYPE_OUTLINE_SNIPPET}).withLocation("pipeline/outline_cull").build());
        OUTLINE_NO_CULL = register(RenderPipeline.builder(new RenderPipeline.Snippet[]{RENDERTYPE_OUTLINE_SNIPPET}).withLocation("pipeline/outline_no_cull").withCull(false).build());
        BILT_SCREEN_LIGHTMAP = register(RenderPipeline.builder(new RenderPipeline.Snippet[0]).withLocation("pipeline/lightmap").withVertexShader("core/blit_screen").withFragmentShader("core/lightmap").withUniform("LightmapInfo", UniformType.UNIFORM_BUFFER).withVertexFormat(VertexFormats.POSITION, DrawMode.QUADS).withDepthWrite(false).withDepthTestFunction(DepthTestFunction.NO_DEPTH_TEST).build());
    }
}

MinecraftClient.class:

//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package net.minecraft.client;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import com.google.common.collect.Queues;
import com.google.common.collect.UnmodifiableIterator;
import com.mojang.authlib.GameProfile;
import com.mojang.authlib.exceptions.AuthenticationException;
import com.mojang.authlib.minecraft.BanDetails;
import com.mojang.authlib.minecraft.MinecraftSessionService;
import com.mojang.authlib.minecraft.UserApiService;
import com.mojang.authlib.minecraft.UserApiService.UserFlag;
import com.mojang.authlib.yggdrasil.ProfileActionType;
import com.mojang.authlib.yggdrasil.ServicesKeyType;
import com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService;
import com.mojang.blaze3d.platform.GLX;
import com.mojang.blaze3d.systems.GpuDevice;
import com.mojang.blaze3d.systems.RenderSystem;
import com.mojang.datafixers.DataFixer;
import com.mojang.jtracy.DiscontinuousFrame;
import com.mojang.jtracy.TracyClient;
import com.mojang.logging.LogUtils;
import java.io.File;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.lang.management.ManagementFactory;
import java.net.Proxy;
import java.net.SocketAddress;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.MissingResourceException;
import java.util.Objects;
import java.util.Optional;
import java.util.Queue;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.IntSupplier;
import java.util.function.Supplier;
import net.fabricmc.api.EnvType;
import net.fabricmc.api.Environment;
import net.minecraft.Bootstrap;
import net.minecraft.SharedConstants;
import net.minecraft.block.Block;
import net.minecraft.block.BlockRenderType;
import net.minecraft.block.BlockState;
import net.minecraft.block.entity.SkullBlockEntity;
import net.minecraft.client.QuickPlayLogger.WorldType;
import net.minecraft.client.color.block.BlockColors;
import net.minecraft.client.font.FontManager;
import net.minecraft.client.font.FreeTypeUtil;
import net.minecraft.client.font.TextRenderer;
import net.minecraft.client.gl.Framebuffer;
import net.minecraft.client.gl.GlTimer;
import net.minecraft.client.gl.ShaderLoader;
import net.minecraft.client.gl.WindowFramebuffer;
import net.minecraft.client.gui.LogoDrawer;
import net.minecraft.client.gui.hud.DebugHud;
import net.minecraft.client.gui.hud.InGameHud;
import net.minecraft.client.gui.hud.debug.PieChart;
import net.minecraft.client.gui.navigation.GuiNavigationType;
import net.minecraft.client.gui.screen.AccessibilityOnboardingScreen;
import net.minecraft.client.gui.screen.ChatScreen;
import net.minecraft.client.gui.screen.ConfirmLinkScreen;
import net.minecraft.client.gui.screen.DeathScreen;
import net.minecraft.client.gui.screen.DownloadingTerrainScreen;
import net.minecraft.client.gui.screen.GameMenuScreen;
import net.minecraft.client.gui.screen.MessageScreen;
import net.minecraft.client.gui.screen.OutOfMemoryScreen;
import net.minecraft.client.gui.screen.Overlay;
import net.minecraft.client.gui.screen.ProgressScreen;
import net.minecraft.client.gui.screen.Screen;
import net.minecraft.client.gui.screen.SleepingChatScreen;
import net.minecraft.client.gui.screen.SplashOverlay;
import net.minecraft.client.gui.screen.TitleScreen;
import net.minecraft.client.gui.screen.advancement.AdvancementsScreen;
import net.minecraft.client.gui.screen.ingame.CreativeInventoryScreen;
import net.minecraft.client.gui.screen.ingame.HandledScreens;
import net.minecraft.client.gui.screen.ingame.InventoryScreen;
import net.minecraft.client.gui.screen.multiplayer.SocialInteractionsScreen;
import net.minecraft.client.gui.screen.world.LevelLoadingScreen;
import net.minecraft.client.item.ItemModelManager;
import net.minecraft.client.network.ClientLoginNetworkHandler;
import net.minecraft.client.network.ClientPlayNetworkHandler;
import net.minecraft.client.network.ClientPlayerEntity;
import net.minecraft.client.network.ClientPlayerInteractionManager;
import net.minecraft.client.network.CookieStorage;
import net.minecraft.client.network.ServerInfo;
import net.minecraft.client.network.SocialInteractionsManager;
import net.minecraft.client.network.message.MessageHandler;
import net.minecraft.client.option.CloudRenderMode;
import net.minecraft.client.option.GameOptions;
import net.minecraft.client.option.GraphicsMode;
import net.minecraft.client.option.HotbarStorage;
import net.minecraft.client.option.InactivityFpsLimiter;
import net.minecraft.client.option.KeyBinding;
import net.minecraft.client.option.NarratorMode;
import net.minecraft.client.option.Perspective;
import net.minecraft.client.particle.ParticleManager;
import net.minecraft.client.realms.RealmsClient;
import net.minecraft.client.realms.RealmsPeriodicCheckers;
import net.minecraft.client.render.BufferBuilderStorage;
import net.minecraft.client.render.GameRenderer;
import net.minecraft.client.render.MapRenderer;
import net.minecraft.client.render.RenderTickCounter;
import net.minecraft.client.render.Tessellator;
import net.minecraft.client.render.WorldRenderer;
import net.minecraft.client.render.block.BlockModels;
import net.minecraft.client.render.block.BlockRenderManager;
import net.minecraft.client.render.block.entity.BlockEntityRenderDispatcher;
import net.minecraft.client.render.debug.DebugRenderer;
import net.minecraft.client.render.entity.EntityRenderDispatcher;
import net.minecraft.client.render.entity.EntityRenderers;
import net.minecraft.client.render.entity.equipment.EquipmentModelLoader;
import net.minecraft.client.render.entity.model.LoadedEntityModels;
import net.minecraft.client.render.item.ItemRenderer;
import net.minecraft.client.render.model.BakedModelManager;
import net.minecraft.client.render.model.BlockStateModel;
import net.minecraft.client.resource.DefaultClientResourcePackProvider;
import net.minecraft.client.resource.DryFoliageColormapResourceSupplier;
import net.minecraft.client.resource.FoliageColormapResourceSupplier;
import net.minecraft.client.resource.GrassColormapResourceSupplier;
import net.minecraft.client.resource.PeriodicNotificationManager;
import net.minecraft.client.resource.ResourceReloadLogger;
import net.minecraft.client.resource.SplashTextResourceSupplier;
import net.minecraft.client.resource.VideoWarningManager;
import net.minecraft.client.resource.ResourceReloadLogger.ReloadReason;
import net.minecraft.client.resource.language.I18n;
import net.minecraft.client.resource.language.LanguageManager;
import net.minecraft.client.resource.server.ServerResourcePackLoader;
import net.minecraft.client.resource.waypoint.WaypointStyleAssetManager;
import net.minecraft.client.session.Bans;
import net.minecraft.client.session.ProfileKeys;
import net.minecraft.client.session.Session;
import net.minecraft.client.session.Session.AccountType;
import net.minecraft.client.session.report.AbuseReportContext;
import net.minecraft.client.session.report.ReporterEnvironment;
import net.minecraft.client.session.telemetry.GameLoadTimeEvent;
import net.minecraft.client.session.telemetry.TelemetryEventProperty;
import net.minecraft.client.session.telemetry.TelemetryManager;
import net.minecraft.client.sound.MusicInstance;
import net.minecraft.client.sound.MusicTracker;
import net.minecraft.client.sound.SoundManager;
import net.minecraft.client.texture.GuiAtlasManager;
import net.minecraft.client.texture.MapDecorationsAtlasManager;
import net.minecraft.client.texture.MapTextureManager;
import net.minecraft.client.texture.PaintingManager;
import net.minecraft.client.texture.PlayerSkinProvider;
import net.minecraft.client.texture.Sprite;
import net.minecraft.client.texture.SpriteAtlasTexture;
import net.minecraft.client.texture.TextureManager;
import net.minecraft.client.toast.SystemToast;
import net.minecraft.client.toast.ToastManager;
import net.minecraft.client.toast.TutorialToast;
import net.minecraft.client.toast.SystemToast.Type;
import net.minecraft.client.tutorial.TutorialManager;
import net.minecraft.client.util.ClientSamplerSource;
import net.minecraft.client.util.CommandHistoryManager;
import net.minecraft.client.util.GlException;
import net.minecraft.client.util.Icons;
import net.minecraft.client.util.NarratorManager;
import net.minecraft.client.util.ScreenshotRecorder;
import net.minecraft.client.util.Window;
import net.minecraft.client.util.WindowProvider;
import net.minecraft.client.util.tracy.TracyFrameCapturer;
import net.minecraft.client.world.ClientWorld;
import net.minecraft.datafixer.Schemas;
import net.minecraft.dialog.Dialogs;
import net.minecraft.dialog.type.Dialog;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityType;
import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraft.network.ClientConnection;
import net.minecraft.network.encryption.SignatureVerifier;
import net.minecraft.network.message.ChatVisibility;
import net.minecraft.network.packet.c2s.login.LoginHelloC2SPacket;
import net.minecraft.network.packet.c2s.play.ClientTickEndC2SPacket;
import net.minecraft.network.packet.c2s.play.PlayerActionC2SPacket;
import net.minecraft.network.packet.c2s.play.PlayerActionC2SPacket.Action;
import net.minecraft.registry.Registries;
import net.minecraft.registry.Registry;
import net.minecraft.registry.RegistryKeys;
import net.minecraft.registry.entry.RegistryEntry;
import net.minecraft.registry.tag.BiomeTags;
import net.minecraft.registry.tag.DialogTags;
import net.minecraft.resource.DefaultResourcePack;
import net.minecraft.resource.FileResourcePackProvider;
import net.minecraft.resource.ReloadableResourceManagerImpl;
import net.minecraft.resource.ResourceManager;
import net.minecraft.resource.ResourcePack;
import net.minecraft.resource.ResourcePackManager;
import net.minecraft.resource.ResourcePackProvider;
import net.minecraft.resource.ResourcePackSource;
import net.minecraft.resource.ResourceReload;
import net.minecraft.resource.ResourceType;
import net.minecraft.screen.ScreenTexts;
import net.minecraft.server.MinecraftServer;
import net.minecraft.server.QueueingWorldGenerationProgressListener;
import net.minecraft.server.SaveLoader;
import net.minecraft.server.WorldGenerationProgressTracker;
import net.minecraft.server.integrated.IntegratedServer;
import net.minecraft.server.integrated.IntegratedServerLoader;
import net.minecraft.sound.MusicSound;
import net.minecraft.sound.MusicType;
import net.minecraft.sound.SoundCategory;
import net.minecraft.test.TestManager;
import net.minecraft.text.ClickEvent;
import net.minecraft.text.KeybindTranslations;
import net.minecraft.text.MutableText;
import net.minecraft.text.Text;
import net.minecraft.util.ActionResult;
import net.minecraft.util.ApiServices;
import net.minecraft.util.Formatting;
import net.minecraft.util.Hand;
import net.minecraft.util.Identifier;
import net.minecraft.util.ModStatus;
import net.minecraft.util.Nullables;
import net.minecraft.util.SystemDetails;
import net.minecraft.util.TickDurationMonitor;
import net.minecraft.util.TimeHelper;
import net.minecraft.util.TimeSupplier;
import net.minecraft.util.Unit;
import net.minecraft.util.Urls;
import net.minecraft.util.UserCache;
import net.minecraft.util.Util;
import net.minecraft.util.ZipCompressor;
import net.minecraft.util.ActionResult.SwingSource;
import net.minecraft.util.Util.OperatingSystem;
import net.minecraft.util.collection.Pool;
import net.minecraft.util.crash.CrashException;
import net.minecraft.util.crash.CrashMemoryReserve;
import net.minecraft.util.crash.CrashReport;
import net.minecraft.util.crash.CrashReportSection;
import net.minecraft.util.crash.ReportType;
import net.minecraft.util.hit.BlockHitResult;
import net.minecraft.util.hit.EntityHitResult;
import net.minecraft.util.hit.HitResult;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Direction;
import net.minecraft.util.path.PathUtil;
import net.minecraft.util.path.SymlinkFinder;
import net.minecraft.util.profiler.DebugRecorder;
import net.minecraft.util.profiler.DummyProfiler;
import net.minecraft.util.profiler.DummyRecorder;
import net.minecraft.util.profiler.EmptyProfileResult;
import net.minecraft.util.profiler.ProfileResult;
import net.minecraft.util.profiler.Profiler;
import net.minecraft.util.profiler.Profilers;
import net.minecraft.util.profiler.RecordDumper;
import net.minecraft.util.profiler.Recorder;
import net.minecraft.util.profiler.ScopedProfiler;
import net.minecraft.util.profiler.TickTimeTracker;
import net.minecraft.util.thread.ReentrantThreadExecutor;
import net.minecraft.world.World;
import net.minecraft.world.biome.Biome;
import net.minecraft.world.level.storage.LevelStorage;
import net.minecraft.world.tick.TickManager;
import org.apache.commons.io.FileUtils;
import org.jetbrains.annotations.Nullable;
import org.lwjgl.util.tinyfd.TinyFileDialogs;
import org.slf4j.Logger;

@Environment(EnvType.CLIENT)
public class MinecraftClient extends ReentrantThreadExecutor<Runnable> implements WindowEventHandler {
    static MinecraftClient instance;
    private static final Logger LOGGER = LogUtils.getLogger();
    public static final boolean IS_SYSTEM_MAC;
    private static final int field_32145 = 10;
    public static final Identifier DEFAULT_FONT_ID;
    public static final Identifier UNICODE_FONT_ID;
    public static final Identifier ALT_TEXT_RENDERER_ID;
    private static final Identifier REGIONAL_COMPLIANCIES_ID;
    private static final CompletableFuture<Unit> COMPLETED_UNIT_FUTURE;
    private static final Text SOCIAL_INTERACTIONS_NOT_AVAILABLE;
    private static final Text SAVING_LEVEL_TEXT;
    public static final String GL_ERROR_DIALOGUE = "Please make sure you have up-to-date drivers (see aka.ms/mcdriver for instructions).";
    private final long UNIVERSE = Double.doubleToLongBits(Math.PI);
    private final Path resourcePackDir;
    private final CompletableFuture<com.mojang.authlib.yggdrasil.ProfileResult> gameProfileFuture;
    private final TextureManager textureManager;
    private final ShaderLoader shaderLoader;
    private final DataFixer dataFixer;
    private final WindowProvider windowProvider;
    private final Window window;
    private final RenderTickCounter.Dynamic renderTickCounter = new RenderTickCounter.Dynamic(20.0F, 0L, this::getTargetMillisPerTick);
    private final BufferBuilderStorage bufferBuilders;
    public final WorldRenderer worldRenderer;
    private final EntityRenderDispatcher entityRenderDispatcher;
    private final ItemModelManager itemModelManager;
    private final ItemRenderer itemRenderer;
    private final MapRenderer mapRenderer;
    public final ParticleManager particleManager;
    private final Session session;
    public final TextRenderer textRenderer;
    public final TextRenderer advanceValidatingTextRenderer;
    public final GameRenderer gameRenderer;
    public final DebugRenderer debugRenderer;
    private final AtomicReference<WorldGenerationProgressTracker> worldGenProgressTracker = new AtomicReference();
    public final InGameHud inGameHud;
    public final GameOptions options;
    private final HotbarStorage creativeHotbarStorage;
    public final Mouse mouse;
    public final Keyboard keyboard;
    private GuiNavigationType navigationType;
    public final File runDirectory;
    private final String gameVersion;
    private final String versionType;
    private final Proxy networkProxy;
    private final LevelStorage levelStorage;
    private final boolean isDemo;
    private final boolean multiplayerEnabled;
    private final boolean onlineChatEnabled;
    private final ReloadableResourceManagerImpl resourceManager;
    private final DefaultResourcePack defaultResourcePack;
    private final ServerResourcePackLoader serverResourcePackLoader;
    private final ResourcePackManager resourcePackManager;
    private final LanguageManager languageManager;
    private final BlockColors blockColors;
    private final Framebuffer framebuffer;
    @Nullable
    private final TracyFrameCapturer tracyFrameCapturer;
    private final SoundManager soundManager;
    private final MusicTracker musicTracker;
    private final FontManager fontManager;
    private final SplashTextResourceSupplier splashTextLoader;
    private final VideoWarningManager videoWarningManager;
    private final PeriodicNotificationManager regionalComplianciesManager;
    private final YggdrasilAuthenticationService authenticationService;
    private final MinecraftSessionService sessionService;
    private final UserApiService userApiService;
    private final CompletableFuture<UserApiService.UserProperties> userPropertiesFuture;
    private final PlayerSkinProvider skinProvider;
    private final BakedModelManager bakedModelManager;
    private final BlockRenderManager blockRenderManager;
    private final PaintingManager paintingManager;
    private final MapTextureManager mapTextureManager;
    private final MapDecorationsAtlasManager mapDecorationsAtlasManager;
    private final GuiAtlasManager guiAtlasManager;
    private final WaypointStyleAssetManager waypointStyleAssetManager;
    private final ToastManager toastManager;
    private final TutorialManager tutorialManager;
    private final SocialInteractionsManager socialInteractionsManager;
    private final BlockEntityRenderDispatcher blockEntityRenderDispatcher;
    private final TelemetryManager telemetryManager;
    private final ProfileKeys profileKeys;
    private final RealmsPeriodicCheckers realmsPeriodicCheckers;
    private final QuickPlayLogger quickPlayLogger;
    @Nullable
    public ClientPlayerInteractionManager interactionManager;
    @Nullable
    public ClientWorld world;
    @Nullable
    public ClientPlayerEntity player;
    @Nullable
    private IntegratedServer server;
    @Nullable
    private ClientConnection integratedServerConnection;
    private boolean integratedServerRunning;
    @Nullable
    public Entity cameraEntity;
    @Nullable
    public Entity targetedEntity;
    @Nullable
    public HitResult crosshairTarget;
    private int itemUseCooldown;
    public int attackCooldown;
    private volatile boolean paused;
    private long lastMetricsSampleTime;
    private long nextDebugInfoUpdateTime;
    private int fpsCounter;
    public boolean skipGameRender;
    @Nullable
    public Screen currentScreen;
    @Nullable
    private Overlay overlay;
    private boolean disconnecting;
    Thread thread;
    private volatile boolean running;
    @Nullable
    private Supplier<CrashReport> crashReportSupplier;
    private static int currentFps;
    public String fpsDebugString;
    private long renderTime;
    private final InactivityFpsLimiter inactivityFpsLimiter;
    public boolean wireFrame;
    public boolean debugChunkInfo;
    public boolean debugChunkOcclusion;
    public boolean chunkCullingEnabled;
    private boolean windowFocused;
    private final Queue<Runnable> renderTaskQueue;
    @Nullable
    private CompletableFuture<Void> resourceReloadFuture;
    @Nullable
    private TutorialToast socialInteractionsToast;
    private int trackingTick;
    private final TickTimeTracker tickTimeTracker;
    private Recorder recorder;
    private final ResourceReloadLogger resourceReloadLogger;
    private long metricsSampleDuration;
    private double gpuUtilizationPercentage;
    @Nullable
    private GlTimer.Query currentGlTimerQuery;
    private final NarratorManager narratorManager;
    private final MessageHandler messageHandler;
    private AbuseReportContext abuseReportContext;
    private final CommandHistoryManager commandHistoryManager;
    private final SymlinkFinder symlinkFinder;
    private boolean finishedLoading;
    private final long startTime;
    private long uptimeInTicks;

    public MinecraftClient(final RunArgs args) {
        super("Client");
        this.navigationType = GuiNavigationType.NONE;
        this.regionalComplianciesManager = new PeriodicNotificationManager(REGIONAL_COMPLIANCIES_ID, MinecraftClient::isCountrySetTo);
        this.lastMetricsSampleTime = Util.getMeasuringTimeNano();
        this.fpsDebugString = "";
        this.chunkCullingEnabled = true;
        this.renderTaskQueue = Queues.newConcurrentLinkedQueue();
        this.recorder = DummyRecorder.INSTANCE;
        this.resourceReloadLogger = new ResourceReloadLogger();
        instance = this;
        this.startTime = System.currentTimeMillis();
        this.runDirectory = args.directories.runDir;
        File file = args.directories.assetDir;
        this.resourcePackDir = args.directories.resourcePackDir.toPath();
        this.gameVersion = args.game.version;
        this.versionType = args.game.versionType;
        Path path = this.runDirectory.toPath();
        this.symlinkFinder = LevelStorage.createSymlinkFinder(path.resolve("allowed_symlinks.txt"));
        DefaultClientResourcePackProvider defaultClientResourcePackProvider = new DefaultClientResourcePackProvider(args.directories.getAssetDir(), this.symlinkFinder);
        this.serverResourcePackLoader = new ServerResourcePackLoader(this, path.resolve("downloads"), args.network);
        ResourcePackProvider resourcePackProvider = new FileResourcePackProvider(this.resourcePackDir, ResourceType.CLIENT_RESOURCES, ResourcePackSource.NONE, this.symlinkFinder);
        this.resourcePackManager = new ResourcePackManager(new ResourcePackProvider[]{defaultClientResourcePackProvider, this.serverResourcePackLoader.getPassthroughPackProvider(), resourcePackProvider});
        this.defaultResourcePack = defaultClientResourcePackProvider.getResourcePack();
        this.networkProxy = args.network.netProxy;
        this.authenticationService = new YggdrasilAuthenticationService(this.networkProxy);
        this.sessionService = this.authenticationService.createMinecraftSessionService();
        this.session = args.network.session;
        this.gameProfileFuture = CompletableFuture.supplyAsync(() -> this.sessionService.fetchProfile(this.session.getUuidOrNull(), true), Util.getDownloadWorkerExecutor());
        this.userApiService = this.createUserApiService(this.authenticationService, args);
        this.userPropertiesFuture = CompletableFuture.supplyAsync(() -> {
            try {
                return this.userApiService.fetchProperties();
            } catch (AuthenticationException authenticationException) {
                LOGGER.error("Failed to fetch user properties", authenticationException);
                return UserApiService.OFFLINE_PROPERTIES;
            }
        }, Util.getDownloadWorkerExecutor());
        LOGGER.info("Setting user: {}", this.session.getUsername());
        LOGGER.debug("(Session ID is {})", this.session.getSessionId());
        this.isDemo = args.game.demo;
        this.multiplayerEnabled = !args.game.multiplayerDisabled;
        this.onlineChatEnabled = !args.game.onlineChatDisabled;
        this.server = null;
        KeybindTranslations.setFactory(KeyBinding::getLocalizedName);
        this.dataFixer = Schemas.getFixer();
        this.thread = Thread.currentThread();
        this.options = new GameOptions(this, this.runDirectory);
        this.toastManager = new ToastManager(this, this.options);
        boolean bl = this.options.startedCleanly;
        this.options.startedCleanly = false;
        this.options.write();
        this.running = true;
        this.tutorialManager = new TutorialManager(this, this.options);
        this.creativeHotbarStorage = new HotbarStorage(path, this.dataFixer);
        LOGGER.info("Backend library: {}", RenderSystem.getBackendDescription());
        WindowSettings windowSettings = args.windowSettings;
        if (this.options.overrideHeight > 0 && this.options.overrideWidth > 0) {
            windowSettings = args.windowSettings.withDimensions(this.options.overrideWidth, this.options.overrideHeight);
        }

        if (!bl) {
            windowSettings = windowSettings.withFullscreen(false);
            this.options.fullscreenResolution = null;
            LOGGER.warn("Detected unexpected shutdown during last game startup: resetting fullscreen mode");
        }

        Util.nanoTimeSupplier = RenderSystem.initBackendSystem();
        this.windowProvider = new WindowProvider(this);
        this.window = this.windowProvider.createWindow(windowSettings, this.options.fullscreenResolution, this.getWindowTitle());
        this.onWindowFocusChanged(true);
        this.window.setCloseCallback(new Runnable() {
            private boolean closed;

            public void run() {
                if (!this.closed) {
                    this.closed = true;
                    ClientWatchdog.shutdownClient(args.directories.runDir, MinecraftClient.this.thread.threadId());
                }

            }
        });
        GameLoadTimeEvent.INSTANCE.stopTimer(TelemetryEventProperty.LOAD_TIME_PRE_WINDOW_MS);

        try {
            this.window.setIcon(this.defaultResourcePack, SharedConstants.getGameVersion().stable() ? Icons.RELEASE : Icons.SNAPSHOT);
        } catch (IOException iOException) {
            LOGGER.error("Couldn't set icon", iOException);
        }

        this.mouse = new Mouse(this);
        this.mouse.setup(this.window.getHandle());
        this.keyboard = new Keyboard(this);
        this.keyboard.setup(this.window.getHandle());
        RenderSystem.initRenderer(this.window.getHandle(), this.options.glDebugVerbosity, false, (id, type) -> this.getShaderLoader().getSource(id, type), args.game.renderDebugLabels);
        LOGGER.info("Using optional rendering extensions: {}", String.join(", ", RenderSystem.getDevice().getEnabledExtensions()));
        this.framebuffer = new WindowFramebuffer(this.window.getFramebufferWidth(), this.window.getFramebufferHeight());
        this.resourceManager = new ReloadableResourceManagerImpl(ResourceType.CLIENT_RESOURCES);
        this.resourcePackManager.scanPacks();
        this.options.addResourcePackProfilesToManager(this.resourcePackManager);
        this.languageManager = new LanguageManager(this.options.language, (translationStorage) -> {
            if (this.player != null) {
                this.player.networkHandler.refreshSearchManager();
            }

        });
        this.resourceManager.registerReloader(this.languageManager);
        this.textureManager = new TextureManager(this.resourceManager);
        this.resourceManager.registerReloader(this.textureManager);
        this.shaderLoader = new ShaderLoader(this.textureManager, this::onShaderResourceReloadFailure);
        this.resourceManager.registerReloader(this.shaderLoader);
        this.skinProvider = new PlayerSkinProvider(file.toPath().resolve("skins"), this.sessionService, this);
        this.levelStorage = new LevelStorage(path.resolve("saves"), path.resolve("backups"), this.symlinkFinder, this.dataFixer);
        this.commandHistoryManager = new CommandHistoryManager(path);
        this.musicTracker = new MusicTracker(this);
        this.soundManager = new SoundManager(this.options, this.musicTracker);
        this.resourceManager.registerReloader(this.soundManager);
        this.splashTextLoader = new SplashTextResourceSupplier(this.session);
        this.resourceManager.registerReloader(this.splashTextLoader);
        this.fontManager = new FontManager(this.textureManager);
        this.textRenderer = this.fontManager.createTextRenderer();
        this.advanceValidatingTextRenderer = this.fontManager.createAdvanceValidatingTextRenderer();
        this.resourceManager.registerReloader(this.fontManager);
        this.onFontOptionsChanged();
        this.resourceManager.registerReloader(new GrassColormapResourceSupplier());
        this.resourceManager.registerReloader(new FoliageColormapResourceSupplier());
        this.resourceManager.registerReloader(new DryFoliageColormapResourceSupplier());
        this.window.setPhase("Startup");
        RenderSystem.setupDefaultState();
        this.window.setPhase("Post startup");
        this.blockColors = BlockColors.create();
        this.bakedModelManager = new BakedModelManager(this.textureManager, this.blockColors, (Integer)this.options.getMipmapLevels().getValue());
        this.resourceManager.registerReloader(this.bakedModelManager);
        EquipmentModelLoader equipmentModelLoader = new EquipmentModelLoader();
        this.resourceManager.registerReloader(equipmentModelLoader);
        this.itemModelManager = new ItemModelManager(this.bakedModelManager);
        this.itemRenderer = new ItemRenderer(this.itemModelManager);
        this.mapTextureManager = new MapTextureManager(this.textureManager);
        this.mapDecorationsAtlasManager = new MapDecorationsAtlasManager(this.textureManager);
        this.resourceManager.registerReloader(this.mapDecorationsAtlasManager);
        this.mapRenderer = new MapRenderer(this.mapDecorationsAtlasManager, this.mapTextureManager);

        try {
            int i = Runtime.getRuntime().availableProcessors();
            Tessellator.initialize();
            this.bufferBuilders = new BufferBuilderStorage(i);
        } catch (OutOfMemoryError outOfMemoryError) {
            TinyFileDialogs.tinyfd_messageBox("Minecraft", "Oh no! The game was unable to allocate memory off-heap while trying to start. You may try to free some memory by closing other applications on your computer, check that your system meets the minimum requirements, and try again. If the problem persists, please visit: " + String.valueOf(Urls.MINECRAFT_SUPPORT), "ok", "error", true);
            throw new GlException("Unable to allocate render buffers", outOfMemoryError);
        }

        this.socialInteractionsManager = new SocialInteractionsManager(this, this.userApiService);
        this.blockRenderManager = new BlockRenderManager(this.bakedModelManager.getBlockModels(), this.bakedModelManager.getBlockEntityModelsSupplier(), this.blockColors);
        this.resourceManager.registerReloader(this.blockRenderManager);
        this.entityRenderDispatcher = new EntityRenderDispatcher(this, this.textureManager, this.itemModelManager, this.itemRenderer, this.mapRenderer, this.blockRenderManager, this.textRenderer, this.options, this.bakedModelManager.getEntityModelsSupplier(), equipmentModelLoader);
        this.resourceManager.registerReloader(this.entityRenderDispatcher);
        this.blockEntityRenderDispatcher = new BlockEntityRenderDispatcher(this.textRenderer, this.bakedModelManager.getEntityModelsSupplier(), this.blockRenderManager, this.itemModelManager, this.itemRenderer, this.entityRenderDispatcher);
        this.resourceManager.registerReloader(this.blockEntityRenderDispatcher);
        this.particleManager = new ParticleManager(this.world, this.textureManager);
        this.resourceManager.registerReloader(this.particleManager);
        this.paintingManager = new PaintingManager(this.textureManager);
        this.resourceManager.registerReloader(this.paintingManager);
        this.guiAtlasManager = new GuiAtlasManager(this.textureManager);
        this.resourceManager.registerReloader(this.guiAtlasManager);
        this.waypointStyleAssetManager = new WaypointStyleAssetManager();
        this.resourceManager.registerReloader(this.waypointStyleAssetManager);
        this.gameRenderer = new GameRenderer(this, this.entityRenderDispatcher.getHeldItemRenderer(), this.bufferBuilders);
        this.worldRenderer = new WorldRenderer(this, this.entityRenderDispatcher, this.blockEntityRenderDispatcher, this.bufferBuilders);
        this.resourceManager.registerReloader(this.worldRenderer);
        this.resourceManager.registerReloader(this.worldRenderer.getCloudRenderer());
        this.videoWarningManager = new VideoWarningManager();
        this.resourceManager.registerReloader(this.videoWarningManager);
        this.resourceManager.registerReloader(this.regionalComplianciesManager);
        this.inGameHud = new InGameHud(this);
        this.debugRenderer = new DebugRenderer(this);
        RealmsClient realmsClient = RealmsClient.createRealmsClient(this);
        this.realmsPeriodicCheckers = new RealmsPeriodicCheckers(realmsClient);
        RenderSystem.setErrorCallback(this::handleGlErrorByDisableVsync);
        if (this.framebuffer.textureWidth == this.window.getFramebufferWidth() && this.framebuffer.textureHeight == this.window.getFramebufferHeight()) {
            if ((Boolean)this.options.getFullscreen().getValue() && !this.window.isFullscreen()) {
                if (bl) {
                    this.window.toggleFullscreen();
                    this.options.getFullscreen().setValue(this.window.isFullscreen());
                } else {
                    this.options.getFullscreen().setValue(false);
                }
            }
        } else {
            int var10002 = this.window.getFramebufferWidth();
            StringBuilder stringBuilder = new StringBuilder("Recovering from unsupported resolution (" + var10002 + "x" + this.window.getFramebufferHeight() + ").\nPlease make sure you have up-to-date drivers (see aka.ms/mcdriver for instructions).");

            try {
                GpuDevice gpuDevice = RenderSystem.getDevice();
                List<String> list = gpuDevice.getLastDebugMessages();
                if (!list.isEmpty()) {
                    stringBuilder.append("\n\nReported GL debug messages:\n").append(String.join("\n", list));
                }
            } catch (Throwable var13) {
            }

            this.window.setWindowedSize(this.framebuffer.textureWidth, this.framebuffer.textureHeight);
            TinyFileDialogs.tinyfd_messageBox("Minecraft", stringBuilder.toString(), "ok", "error", false);
        }

        this.window.setVsync((Boolean)this.options.getEnableVsync().getValue());
        this.window.setRawMouseMotion((Boolean)this.options.getRawMouseInput().getValue());
        this.window.logOnGlError();
        this.onResolutionChanged();
        this.gameRenderer.preloadPrograms(this.defaultResourcePack.getFactory());
        this.telemetryManager = new TelemetryManager(this, this.userApiService, this.session);
        this.profileKeys = ProfileKeys.create(this.userApiService, this.session, path);
        this.narratorManager = new NarratorManager(this);
        this.narratorManager.checkNarratorLibrary(this.options.getNarrator().getValue() != NarratorMode.OFF);
        this.messageHandler = new MessageHandler(this);
        this.messageHandler.setChatDelay((Double)this.options.getChatDelay().getValue());
        this.abuseReportContext = AbuseReportContext.create(ReporterEnvironment.ofIntegratedServer(), this.userApiService);
        TitleScreen.registerTextures(this.textureManager);
        SplashOverlay.init(this.textureManager);
        this.gameRenderer.getRotatingPanoramaRenderer().registerTextures(this.textureManager);
        this.setScreen(new MessageScreen(Text.translatable("gui.loadingMinecraft")));
        List<ResourcePack> list2 = this.resourcePackManager.createResourcePacks();
        this.resourceReloadLogger.reload(ReloadReason.INITIAL, list2);
        ResourceReload resourceReload = this.resourceManager.reload(Util.getMainWorkerExecutor().named("resourceLoad"), this, COMPLETED_UNIT_FUTURE, list2);
        GameLoadTimeEvent.INSTANCE.startTimer(TelemetryEventProperty.LOAD_TIME_LOADING_OVERLAY_MS);
        LoadingContext loadingContext = new LoadingContext(realmsClient, args.quickPlay);
        this.setOverlay(new SplashOverlay(this, resourceReload, (error) -> Util.ifPresentOrElse(error, (throwable) -> this.handleResourceReloadException(throwable, loadingContext), () -> {
                if (SharedConstants.isDevelopment) {
                    this.checkGameData();
                }

                this.resourceReloadLogger.finish();
                this.onFinishedLoading(loadingContext);
            }), false));
        this.quickPlayLogger = QuickPlayLogger.create(args.quickPlay.logPath());
        this.inactivityFpsLimiter = new InactivityFpsLimiter(this.options, this);
        TimeSupplier.Nanoseconds var10003 = Util.nanoTimeSupplier;
        IntSupplier var10004 = () -> this.trackingTick;
        InactivityFpsLimiter var10005 = this.inactivityFpsLimiter;
        Objects.requireNonNull(var10005);
        this.tickTimeTracker = new TickTimeTracker(var10003, var10004, var10005::shouldDisableProfilerTimeout);
        if (TracyClient.isAvailable() && args.game.tracyEnabled) {
            this.tracyFrameCapturer = new TracyFrameCapturer();
        } else {
            this.tracyFrameCapturer = null;
        }

    }

    private void onFinishedLoading(@Nullable LoadingContext loadingContext) {
        if (!this.finishedLoading) {
            this.finishedLoading = true;
            this.collectLoadTimes(loadingContext);
        }

    }

    private void collectLoadTimes(@Nullable LoadingContext loadingContext) {
        Runnable runnable = this.onInitFinished(loadingContext);
        GameLoadTimeEvent.INSTANCE.stopTimer(TelemetryEventProperty.LOAD_TIME_LOADING_OVERLAY_MS);
        GameLoadTimeEvent.INSTANCE.stopTimer(TelemetryEventProperty.LOAD_TIME_TOTAL_TIME_MS);
        GameLoadTimeEvent.INSTANCE.send(this.telemetryManager.getSender());
        runnable.run();
        this.options.startedCleanly = true;
        this.options.write();
    }

    public boolean isFinishedLoading() {
        return this.finishedLoading;
    }

    private Runnable onInitFinished(@Nullable LoadingContext loadingContext) {
        List<Function<Runnable, Screen>> list = new ArrayList();
        boolean bl = this.createInitScreens(list);
        Runnable runnable = () -> {
            if (loadingContext != null && loadingContext.quickPlayData.isEnabled()) {
                QuickPlay.startQuickPlay(this, loadingContext.quickPlayData.variant(), loadingContext.realmsClient());
            } else {
                this.setScreen(new TitleScreen(true, new LogoDrawer(bl)));
            }

        };

        for(Function<Runnable, Screen> function : Lists.reverse(list)) {
            Screen screen = (Screen)function.apply(runnable);
            runnable = () -> this.setScreen(screen);
        }

        return runnable;
    }

    private boolean createInitScreens(List<Function<Runnable, Screen>> list) {
        boolean bl = false;
        if (this.options.onboardAccessibility) {
            list.add((Function)(onClose) -> new AccessibilityOnboardingScreen(this.options, onClose));
            bl = true;
        }

        BanDetails banDetails = this.getMultiplayerBanDetails();
        if (banDetails != null) {
            list.add((Function)(onClose) -> Bans.createBanScreen((confirmed) -> {
                    if (confirmed) {
                        Util.getOperatingSystem().open(Urls.JAVA_MODERATION);
                    }

                    onClose.run();
                }, banDetails));
        }

        com.mojang.authlib.yggdrasil.ProfileResult profileResult = (com.mojang.authlib.yggdrasil.ProfileResult)this.gameProfileFuture.join();
        if (profileResult != null) {
            GameProfile gameProfile = profileResult.profile();
            Set<ProfileActionType> set = profileResult.actions();
            if (set.contains(ProfileActionType.FORCED_NAME_CHANGE)) {
                list.add((Function)(onClose) -> Bans.createUsernameBanScreen(gameProfile.getName(), onClose));
            }

            if (set.contains(ProfileActionType.USING_BANNED_SKIN)) {
                list.add(Bans::createSkinBanScreen);
            }
        }

        return bl;
    }

    private static boolean isCountrySetTo(Object country) {
        try {
            return Locale.getDefault().getISO3Country().equals(country);
        } catch (MissingResourceException var2) {
            return false;
        }
    }

    public void updateWindowTitle() {
        this.window.setTitle(this.getWindowTitle());
    }

    private String getWindowTitle() {
        StringBuilder stringBuilder = new StringBuilder("Minecraft");
        if (getModStatus().isModded()) {
            stringBuilder.append("*");
        }

        stringBuilder.append(" ");
        stringBuilder.append(SharedConstants.getGameVersion().name());
        ClientPlayNetworkHandler clientPlayNetworkHandler = this.getNetworkHandler();
        if (clientPlayNetworkHandler != null && clientPlayNetworkHandler.getConnection().isOpen()) {
            stringBuilder.append(" - ");
            ServerInfo serverInfo = this.getCurrentServerEntry();
            if (this.server != null && !this.server.isRemote()) {
                stringBuilder.append(I18n.translate("title.singleplayer", new Object[0]));
            } else if (serverInfo != null && serverInfo.isRealm()) {
                stringBuilder.append(I18n.translate("title.multiplayer.realms", new Object[0]));
            } else if (this.server == null && (serverInfo == null || !serverInfo.isLocal())) {
                stringBuilder.append(I18n.translate("title.multiplayer.other", new Object[0]));
            } else {
                stringBuilder.append(I18n.translate("title.multiplayer.lan", new Object[0]));
            }
        }

        return stringBuilder.toString();
    }

    private UserApiService createUserApiService(YggdrasilAuthenticationService authService, RunArgs runArgs) {
        return runArgs.network.session.getAccountType() != AccountType.MSA ? UserApiService.OFFLINE : authService.createUserApiService(runArgs.network.session.getAccessToken());
    }

    public static ModStatus getModStatus() {
        return ModStatus.check("vanilla", ClientBrandRetriever::getClientModName, "Client", MinecraftClient.class);
    }

    private void handleResourceReloadException(Throwable throwable, @Nullable LoadingContext loadingContext) {
        if (this.resourcePackManager.getEnabledIds().size() > 1) {
            this.onResourceReloadFailure(throwable, (Text)null, loadingContext);
        } else {
            Util.throwUnchecked(throwable);
        }

    }

    public void onResourceReloadFailure(Throwable exception, @Nullable Text resourceName, @Nullable LoadingContext loadingContext) {
        LOGGER.info("Caught error loading resourcepacks, removing all selected resourcepacks", exception);
        this.resourceReloadLogger.recover(exception);
        this.serverResourcePackLoader.onReloadFailure();
        this.resourcePackManager.setEnabledProfiles(Collections.emptyList());
        this.options.resourcePacks.clear();
        this.options.incompatibleResourcePacks.clear();
        this.options.write();
        this.reloadResources(true, loadingContext).thenRunAsync(() -> this.showResourceReloadFailureToast(resourceName), this);
    }

    private void onForcedResourceReloadFailure() {
        this.setOverlay((Overlay)null);
        if (this.world != null) {
            this.world.disconnect(ClientWorld.QUITTING_MULTIPLAYER_TEXT);
            this.disconnectWithProgressScreen();
        }

        this.setScreen(new TitleScreen());
        this.showResourceReloadFailureToast((Text)null);
    }

    private void showResourceReloadFailureToast(@Nullable Text description) {
        ToastManager toastManager = this.getToastManager();
        SystemToast.show(toastManager, Type.PACK_LOAD_FAILURE, Text.translatable("resourcePack.load_fail"), description);
    }

    public void onShaderResourceReloadFailure(Exception exception) {
        if (!this.resourcePackManager.hasOptionalProfilesEnabled()) {
            if (this.resourcePackManager.getEnabledIds().size() <= 1) {
                LOGGER.error(LogUtils.FATAL_MARKER, exception.getMessage(), exception);
                this.printCrashReport(new CrashReport(exception.getMessage(), exception));
            } else {
                this.send(this::onForcedResourceReloadFailure);
            }

        } else {
            this.onResourceReloadFailure(exception, Text.translatable("resourcePack.runtime_failure"), (LoadingContext)null);
        }
    }

    public void run() {
        this.thread = Thread.currentThread();
        if (Runtime.getRuntime().availableProcessors() > 4) {
            this.thread.setPriority(10);
        }

        DiscontinuousFrame discontinuousFrame = TracyClient.createDiscontinuousFrame("Client Tick");

        try {
            boolean bl = false;

            while(this.running) {
                this.printCrashReport();

                try {
                    TickDurationMonitor tickDurationMonitor = TickDurationMonitor.create("Renderer");
                    boolean bl2 = this.getDebugHud().shouldShowRenderingChart();

                    try (Profilers.Scoped scoped = Profilers.using(this.startMonitor(bl2, tickDurationMonitor))) {
                        this.recorder.startTick();
                        discontinuousFrame.start();
                        this.render(!bl);
                        discontinuousFrame.end();
                        this.recorder.endTick();
                    }

                    this.endMonitor(bl2, tickDurationMonitor);
                } catch (OutOfMemoryError outOfMemoryError) {
                    if (bl) {
                        throw outOfMemoryError;
                    }

                    this.cleanUpAfterCrash();
                    this.setScreen(new OutOfMemoryScreen());
                    System.gc();
                    LOGGER.error(LogUtils.FATAL_MARKER, "Out of memory", outOfMemoryError);
                    bl = true;
                }
            }
        } catch (CrashException crashException) {
            LOGGER.error(LogUtils.FATAL_MARKER, "Reported exception thrown!", crashException);
            this.printCrashReport(crashException.getReport());
        } catch (Throwable throwable) {
            LOGGER.error(LogUtils.FATAL_MARKER, "Unreported exception thrown!", throwable);
            this.printCrashReport(new CrashReport("Unexpected error", throwable));
        }

    }

    void onFontOptionsChanged() {
        this.fontManager.setActiveFilters(this.options);
    }

    private void handleGlErrorByDisableVsync(int error, long description) {
        this.options.getEnableVsync().setValue(false);
        this.options.write();
    }

    public Framebuffer getFramebuffer() {
        return this.framebuffer;
    }

    public String getGameVersion() {
        return this.gameVersion;
    }

    public String getVersionType() {
        return this.versionType;
    }

    public void setCrashReportSupplierAndAddDetails(CrashReport crashReport) {
        this.crashReportSupplier = () -> this.addDetailsToCrashReport(crashReport);
    }

    public void setCrashReportSupplier(CrashReport crashReport) {
        this.crashReportSupplier = () -> crashReport;
    }

    private void printCrashReport() {
        if (this.crashReportSupplier != null) {
            printCrashReport(this, this.runDirectory, (CrashReport)this.crashReportSupplier.get());
        }

    }

    public void printCrashReport(CrashReport crashReport) {
        CrashMemoryReserve.releaseMemory();
        CrashReport crashReport2 = this.addDetailsToCrashReport(crashReport);
        this.cleanUpAfterCrash();
        printCrashReport(this, this.runDirectory, crashReport2);
    }

    public static int saveCrashReport(File runDir, CrashReport crashReport) {
        Path path = runDir.toPath().resolve("crash-reports");
        Path path2 = path.resolve("crash-" + Util.getFormattedCurrentTime() + "-client.txt");
        Bootstrap.println(crashReport.asString(ReportType.MINECRAFT_CRASH_REPORT));
        if (crashReport.getFile() != null) {
            Bootstrap.println("#@!@# Game crashed! Crash report saved to: #@!@# " + String.valueOf(crashReport.getFile().toAbsolutePath()));
            return -1;
        } else if (crashReport.writeToFile(path2, ReportType.MINECRAFT_CRASH_REPORT)) {
            Bootstrap.println("#@!@# Game crashed! Crash report saved to: #@!@# " + String.valueOf(path2.toAbsolutePath()));
            return -1;
        } else {
            Bootstrap.println("#@?@# Game crashed! Crash report could not be saved. #@?@#");
            return -2;
        }
    }

    public static void printCrashReport(@Nullable MinecraftClient client, File runDirectory, CrashReport crashReport) {
        int i = saveCrashReport(runDirectory, crashReport);
        if (client != null) {
            client.soundManager.stopAbruptly();
        }

        System.exit(i);
    }

    public boolean forcesUnicodeFont() {
        return (Boolean)this.options.getForceUnicodeFont().getValue();
    }

    public CompletableFuture<Void> reloadResources() {
        return this.reloadResources(false, (LoadingContext)null);
    }

    private CompletableFuture<Void> reloadResources(boolean force, @Nullable LoadingContext loadingContext) {
        if (this.resourceReloadFuture != null) {
            return this.resourceReloadFuture;
        } else {
            CompletableFuture<Void> completableFuture = new CompletableFuture();
            if (!force && this.overlay instanceof SplashOverlay) {
                this.resourceReloadFuture = completableFuture;
                return completableFuture;
            } else {
                this.resourcePackManager.scanPacks();
                List<ResourcePack> list = this.resourcePackManager.createResourcePacks();
                if (!force) {
                    this.resourceReloadLogger.reload(ReloadReason.MANUAL, list);
                }

                this.setOverlay(new SplashOverlay(this, this.resourceManager.reload(Util.getMainWorkerExecutor().named("resourceLoad"), this, COMPLETED_UNIT_FUTURE, list), (error) -> Util.ifPresentOrElse(error, (throwable) -> {
                        if (force) {
                            this.serverResourcePackLoader.onForcedReloadFailure();
                            this.onForcedResourceReloadFailure();
                        } else {
                            this.handleResourceReloadException(throwable, loadingContext);
                        }

                    }, () -> {
                        this.worldRenderer.reload();
                        this.resourceReloadLogger.finish();
                        this.serverResourcePackLoader.onReloadSuccess();
                        completableFuture.complete((Object)null);
                        this.onFinishedLoading(loadingContext);
                    }), !force));
                return completableFuture;
            }
        }
    }

    private void checkGameData() {
        boolean bl = false;
        BlockModels blockModels = this.getBlockRenderManager().getModels();
        BlockStateModel blockStateModel = blockModels.getModelManager().getMissingModel();

        for(Block block : Registries.BLOCK) {
            UnmodifiableIterator var6 = block.getStateManager().getStates().iterator();

            while(var6.hasNext()) {
                BlockState blockState = (BlockState)var6.next();
                if (blockState.getRenderType() == BlockRenderType.MODEL) {
                    BlockStateModel blockStateModel2 = blockModels.getModel(blockState);
                    if (blockStateModel2 == blockStateModel) {
                        LOGGER.debug("Missing model for: {}", blockState);
                        bl = true;
                    }
                }
            }
        }

        Sprite sprite = blockStateModel.particleSprite();

        for(Block block2 : Registries.BLOCK) {
            UnmodifiableIterator var15 = block2.getStateManager().getStates().iterator();

            while(var15.hasNext()) {
                BlockState blockState2 = (BlockState)var15.next();
                Sprite sprite2 = blockModels.getModelParticleSprite(blockState2);
                if (!blockState2.isAir() && sprite2 == sprite) {
                    LOGGER.debug("Missing particle icon for: {}", blockState2);
                }
            }
        }

        Registries.ITEM.streamEntries().forEach((item) -> {
            Item item2 = (Item)item.value();
            String string = item2.getTranslationKey();
            String string2 = Text.translatable(string).getString();
            if (string2.toLowerCase(Locale.ROOT).equals(item2.getTranslationKey())) {
                LOGGER.debug("Missing translation for: {} {} {}", new Object[]{item.registryKey().getValue(), string, item2});
            }

        });
        bl |= HandledScreens.isMissingScreens();
        bl |= EntityRenderers.isMissingRendererFactories();
        if (bl) {
            throw new IllegalStateException("Your game data is foobar, fix the errors above!");
        }
    }

    public LevelStorage getLevelStorage() {
        return this.levelStorage;
    }

    private void openChatScreen(String text) {
        ChatRestriction chatRestriction = this.getChatRestriction();
        if (!chatRestriction.allowsChat(this.isInSingleplayer())) {
            if (this.inGameHud.shouldShowChatDisabledScreen()) {
                this.inGameHud.setCanShowChatDisabledScreen(false);
                this.setScreen(new ConfirmLinkScreen((confirmed) -> {
                    if (confirmed) {
                        Util.getOperatingSystem().open(Urls.JAVA_ACCOUNT_SETTINGS);
                    }

                    this.setScreen((Screen)null);
                }, MinecraftClient.ChatRestriction.MORE_INFO_TEXT, Urls.JAVA_ACCOUNT_SETTINGS, true));
            } else {
                Text text2 = chatRestriction.getDescription();
                this.inGameHud.setOverlayMessage(text2, false);
                this.narratorManager.narrateSystemImmediately(text2);
                this.inGameHud.setCanShowChatDisabledScreen(chatRestriction == MinecraftClient.ChatRestriction.DISABLED_BY_PROFILE);
            }
        } else {
            this.setScreen(new ChatScreen(text));
        }

    }

    public void setScreen(@Nullable Screen screen) {
        if (SharedConstants.isDevelopment && Thread.currentThread() != this.thread) {
            LOGGER.error("setScreen called from non-game thread");
        }

        if (this.currentScreen != null) {
            this.currentScreen.removed();
        } else {
            this.setNavigationType(GuiNavigationType.NONE);
        }

        if (screen == null && this.disconnecting) {
            throw new IllegalStateException("Trying to return to in-game GUI during disconnection");
        } else {
            if (screen == null && this.world == null) {
                screen = new TitleScreen();
            } else if (screen == null && this.player.isDead()) {
                if (this.player.showsDeathScreen()) {
                    screen = new DeathScreen((Text)null, this.world.getLevelProperties().isHardcore());
                } else {
                    this.player.requestRespawn();
                }
            }

            this.currentScreen = screen;
            if (this.currentScreen != null) {
                this.currentScreen.onDisplayed();
            }

            if (screen != null) {
                this.mouse.unlockCursor();
                KeyBinding.unpressAll();
                screen.init(this, this.window.getScaledWidth(), this.window.getScaledHeight());
                this.skipGameRender = false;
            } else {
                this.soundManager.resumeAll();
                this.mouse.lockCursor();
            }

            this.updateWindowTitle();
        }
    }

    public void setOverlay(@Nullable Overlay overlay) {
        this.overlay = overlay;
    }

    public void stop() {
        try {
            LOGGER.info("Stopping!");

            try {
                this.narratorManager.destroy();
            } catch (Throwable var7) {
            }

            try {
                if (this.world != null) {
                    this.world.disconnect(ClientWorld.QUITTING_MULTIPLAYER_TEXT);
                }

                this.disconnectWithProgressScreen();
            } catch (Throwable var6) {
            }

            if (this.currentScreen != null) {
                this.currentScreen.removed();
            }

            this.close();
        } finally {
            Util.nanoTimeSupplier = System::nanoTime;
            if (this.crashReportSupplier == null) {
                System.exit(0);
            }

        }

    }

    public void close() {
        if (this.currentGlTimerQuery != null) {
            this.currentGlTimerQuery.close();
        }

        try {
            this.telemetryManager.close();
            this.regionalComplianciesManager.close();
            this.bakedModelManager.close();
            this.fontManager.close();
            this.gameRenderer.close();
            this.shaderLoader.close();
            this.worldRenderer.close();
            this.soundManager.close();
            this.particleManager.clearAtlas();
            this.paintingManager.close();
            this.mapDecorationsAtlasManager.close();
            this.guiAtlasManager.close();
            this.mapTextureManager.close();
            this.textureManager.close();
            this.resourceManager.close();
            if (this.tracyFrameCapturer != null) {
                this.tracyFrameCapturer.close();
            }

            FreeTypeUtil.release();
            Util.shutdownExecutors();
            RenderSystem.getDevice().close();
        } catch (Throwable throwable) {
            LOGGER.error("Shutdown failure!", throwable);
            throw throwable;
        } finally {
            this.windowProvider.close();
            this.window.close();
        }

    }

    private void render(boolean tick) {
        this.window.setPhase("Pre render");
        if (this.window.shouldClose()) {
            this.scheduleStop();
        }

        if (this.resourceReloadFuture != null && !(this.overlay instanceof SplashOverlay)) {
            CompletableFuture<Void> completableFuture = this.resourceReloadFuture;
            this.resourceReloadFuture = null;
            this.reloadResources().thenRun(() -> completableFuture.complete((Object)null));
        }

        Runnable runnable;
        while((runnable = (Runnable)this.renderTaskQueue.poll()) != null) {
            runnable.run();
        }

        int i = this.renderTickCounter.beginRenderTick(Util.getMeasuringTimeMs(), tick);
        Profiler profiler = Profilers.get();
        if (tick) {
            profiler.push("scheduledExecutables");
            this.runTasks();
            profiler.pop();
            profiler.push("tick");

            for(int j = 0; j < Math.min(10, i); ++j) {
                profiler.visit("clientTick");
                this.tick();
            }

            profiler.pop();
        }

        this.window.setPhase("Render");
        profiler.push("gpuAsync");
        RenderSystem.executePendingTasks();
        profiler.swap("sound");
        this.soundManager.updateListenerPosition(this.gameRenderer.getCamera());
        profiler.swap("toasts");
        this.toastManager.update();
        profiler.swap("render");
        long l = Util.getMeasuringTimeNano();
        boolean bl;
        if (!this.getDebugHud().shouldShowDebugHud() && !this.recorder.isActive()) {
            bl = false;
            this.gpuUtilizationPercentage = (double)0.0F;
        } else {
            bl = this.currentGlTimerQuery == null || this.currentGlTimerQuery.isResultAvailable();
            if (bl) {
                GlTimer.getInstance().ifPresent(GlTimer::beginProfile);
            }
        }

        Framebuffer framebuffer = this.getFramebuffer();
        RenderSystem.getDevice().createCommandEncoder().clearColorAndDepthTextures(framebuffer.getColorAttachment(), 0, framebuffer.getDepthAttachment(), (double)1.0F);
        profiler.push("mouse");
        this.mouse.tick();
        profiler.pop();
        if (!this.skipGameRender) {
            profiler.swap("gameRenderer");
            this.gameRenderer.render(this.renderTickCounter, tick);
            profiler.pop();
        }

        profiler.push("blit");
        if (!this.window.hasZeroWidthOrHeight()) {
            framebuffer.blitToScreen();
        }

        this.renderTime = Util.getMeasuringTimeNano() - l;
        if (bl) {
            GlTimer.getInstance().ifPresent((glTimer) -> this.currentGlTimerQuery = glTimer.endProfile());
        }

        profiler.swap("updateDisplay");
        if (this.tracyFrameCapturer != null) {
            this.tracyFrameCapturer.upload();
            this.tracyFrameCapturer.capture(framebuffer);
        }

        this.window.swapBuffers(this.tracyFrameCapturer);
        int k = this.inactivityFpsLimiter.update();
        if (k < 260) {
            RenderSystem.limitDisplayFPS(k);
        }

        profiler.swap("yield");
        Thread.yield();
        profiler.pop();
        this.window.setPhase("Post render");
        ++this.fpsCounter;
        boolean bl2 = this.paused;
        this.paused = this.isIntegratedServerRunning() && (this.currentScreen != null && this.currentScreen.shouldPause() || this.overlay != null && this.overlay.pausesGame()) && !this.server.isRemote();
        if (!bl2 && this.paused) {
            this.soundManager.pauseAllExcept(new SoundCategory[]{SoundCategory.MUSIC, SoundCategory.UI});
        }

        this.renderTickCounter.tick(this.paused);
        this.renderTickCounter.setTickFrozen(!this.shouldTick());
        long m = Util.getMeasuringTimeNano();
        long n = m - this.lastMetricsSampleTime;
        if (bl) {
            this.metricsSampleDuration = n;
        }

        this.getDebugHud().pushToFrameLog(n);
        this.lastMetricsSampleTime = m;
        profiler.push("fpsUpdate");
        if (this.currentGlTimerQuery != null && this.currentGlTimerQuery.isResultAvailable()) {
            this.gpuUtilizationPercentage = (double)this.currentGlTimerQuery.queryResult() * (double)100.0F / (double)this.metricsSampleDuration;
        }

        while(Util.getMeasuringTimeMs() >= this.nextDebugInfoUpdateTime + 1000L) {
            String string;
            if (this.gpuUtilizationPercentage > (double)0.0F) {
                String var10000 = this.gpuUtilizationPercentage > (double)100.0F ? String.valueOf(Formatting.RED) + "100%" : Math.round(this.gpuUtilizationPercentage) + "%";
                string = " GPU: " + var10000;
            } else {
                string = "";
            }

            currentFps = this.fpsCounter;
            this.fpsDebugString = String.format(Locale.ROOT, "%d fps T: %s%s%s%s B: %d%s", currentFps, k == 260 ? "inf" : k, (Boolean)this.options.getEnableVsync().getValue() ? " vsync " : " ", this.options.getGraphicsMode().getValue(), this.options.getCloudRenderMode().getValue() == CloudRenderMode.OFF ? "" : (this.options.getCloudRenderMode().getValue() == CloudRenderMode.FAST ? " fast-clouds" : " fancy-clouds"), this.options.getBiomeBlendRadius().getValue(), string);
            this.nextDebugInfoUpdateTime += 1000L;
            this.fpsCounter = 0;
        }

        profiler.pop();
    }

    private Profiler startMonitor(boolean active, @Nullable TickDurationMonitor monitor) {
        if (!active) {
            this.tickTimeTracker.disable();
            if (!this.recorder.isActive() && monitor == null) {
                return DummyProfiler.INSTANCE;
            }
        }

        Profiler profiler;
        if (active) {
            if (!this.tickTimeTracker.isActive()) {
                this.trackingTick = 0;
                this.tickTimeTracker.enable();
            }

            ++this.trackingTick;
            profiler = this.tickTimeTracker.getProfiler();
        } else {
            profiler = DummyProfiler.INSTANCE;
        }

        if (this.recorder.isActive()) {
            profiler = Profiler.union(profiler, this.recorder.getProfiler());
        }

        return TickDurationMonitor.tickProfiler(profiler, monitor);
    }

    private void endMonitor(boolean active, @Nullable TickDurationMonitor monitor) {
        if (monitor != null) {
            monitor.endTick();
        }

        PieChart pieChart = this.getDebugHud().getPieChart();
        if (active) {
            pieChart.setProfileResult(this.tickTimeTracker.getResult());
        } else {
            pieChart.setProfileResult((ProfileResult)null);
        }

    }

    public void onResolutionChanged() {
        int i = this.window.calculateScaleFactor((Integer)this.options.getGuiScale().getValue(), this.forcesUnicodeFont());
        this.window.setScaleFactor(i);
        if (this.currentScreen != null) {
            this.currentScreen.resize(this, this.window.getScaledWidth(), this.window.getScaledHeight());
        }

        Framebuffer framebuffer = this.getFramebuffer();
        framebuffer.resize(this.window.getFramebufferWidth(), this.window.getFramebufferHeight());
        this.gameRenderer.onResized(this.window.getFramebufferWidth(), this.window.getFramebufferHeight());
        this.mouse.onResolutionChanged();
    }

    public void onCursorEnterChanged() {
        this.mouse.setResolutionChanged();
    }

    public int getCurrentFps() {
        return currentFps;
    }

    public long getRenderTime() {
        return this.renderTime;
    }

    private void cleanUpAfterCrash() {
        CrashMemoryReserve.releaseMemory();

        try {
            if (this.integratedServerRunning && this.server != null) {
                this.server.stop(true);
            }

            this.disconnectWithSavingScreen();
        } catch (Throwable var2) {
        }

        System.gc();
    }

    public boolean toggleDebugProfiler(Consumer<Text> chatMessageSender) {
        if (this.recorder.isActive()) {
            this.stopRecorder();
            return false;
        } else {
            Consumer<ProfileResult> consumer = (result) -> {
                if (result != EmptyProfileResult.INSTANCE) {
                    int i = result.getTickSpan();
                    double d = (double)result.getTimeSpan() / (double)TimeHelper.SECOND_IN_NANOS;
                    this.execute(() -> chatMessageSender.accept(Text.translatable("commands.debug.stopped", new Object[]{String.format(Locale.ROOT, "%.2f", d), i, String.format(Locale.ROOT, "%.2f", (double)i / d)})));
                }
            };
            Consumer<Path> consumer2 = (path) -> {
                Text text = Text.literal(path.toString()).formatted(Formatting.UNDERLINE).styled((style) -> style.withClickEvent(new ClickEvent.OpenFile(path.getParent())));
                this.execute(() -> chatMessageSender.accept(Text.translatable("debug.profiling.stop", new Object[]{text})));
            };
            SystemDetails systemDetails = addSystemDetailsToCrashReport(new SystemDetails(), this, this.languageManager, this.gameVersion, this.options);
            Consumer<List<Path>> consumer3 = (files) -> {
                Path path = this.saveProfilingResult(systemDetails, files);
                consumer2.accept(path);
            };
            Consumer<Path> consumer4;
            if (this.server == null) {
                consumer4 = (path) -> consumer3.accept(ImmutableList.of(path));
            } else {
                this.server.addSystemDetails(systemDetails);
                CompletableFuture<Path> completableFuture = new CompletableFuture();
                CompletableFuture<Path> completableFuture2 = new CompletableFuture();
                CompletableFuture.allOf(completableFuture, completableFuture2).thenRunAsync(() -> consumer3.accept(ImmutableList.of((Path)completableFuture.join(), (Path)completableFuture2.join())), Util.getIoWorkerExecutor());
                IntegratedServer var10000 = this.server;
                Consumer var10001 = (result) -> {
                };
                Objects.requireNonNull(completableFuture2);
                var10000.setupRecorder(var10001, completableFuture2::complete);
                Objects.requireNonNull(completableFuture);
                consumer4 = completableFuture::complete;
            }

            this.recorder = DebugRecorder.of(new ClientSamplerSource(Util.nanoTimeSupplier, this.worldRenderer), Util.nanoTimeSupplier, Util.getIoWorkerExecutor(), new RecordDumper("client"), (result) -> {
                this.recorder = DummyRecorder.INSTANCE;
                consumer.accept(result);
            }, consumer4);
            return true;
        }
    }

    private void stopRecorder() {
        this.recorder.stop();
        if (this.server != null) {
            this.server.stopRecorder();
        }

    }

    private void forceStopRecorder() {
        this.recorder.forceStop();
        if (this.server != null) {
            this.server.forceStopRecorder();
        }

    }

    private Path saveProfilingResult(SystemDetails details, List<Path> files) {
        String string;
        if (this.isInSingleplayer()) {
            string = this.getServer().getSaveProperties().getLevelName();
        } else {
            ServerInfo serverInfo = this.getCurrentServerEntry();
            string = serverInfo != null ? serverInfo.name : "unknown";
        }

        Path path;
        try {
            String string2 = String.format(Locale.ROOT, "%s-%s-%s", Util.getFormattedCurrentTime(), string, SharedConstants.getGameVersion().id());
            String string3 = PathUtil.getNextUniqueName(RecordDumper.DEBUG_PROFILING_DIRECTORY, string2, ".zip");
            path = RecordDumper.DEBUG_PROFILING_DIRECTORY.resolve(string3);
        } catch (IOException iOException) {
            throw new UncheckedIOException(iOException);
        }

        try {
            ZipCompressor zipCompressor = new ZipCompressor(path);

            try {
                zipCompressor.write(Paths.get("system.txt"), details.collect());
                zipCompressor.write(Paths.get("client").resolve(this.options.getOptionsFile().getName()), this.options.collectProfiledOptions());
                Objects.requireNonNull(zipCompressor);
                files.forEach(zipCompressor::copyAll);
            } catch (Throwable var20) {
                try {
                    zipCompressor.close();
                } catch (Throwable var19) {
                    var20.addSuppressed(var19);
                }

                throw var20;
            }

            zipCompressor.close();
        } finally {
            for(Path path3 : files) {
                try {
                    FileUtils.forceDelete(path3.toFile());
                } catch (IOException iOException3) {
                    LOGGER.warn("Failed to delete temporary profiling result {}", path3, iOException3);
                }
            }

        }

        return path;
    }

    public void scheduleStop() {
        this.running = false;
    }

    public boolean isRunning() {
        return this.running;
    }

    public void openGameMenu(boolean pauseOnly) {
        if (this.currentScreen == null) {
            boolean bl = this.isIntegratedServerRunning() && !this.server.isRemote();
            if (bl) {
                this.setScreen(new GameMenuScreen(!pauseOnly));
            } else {
                this.setScreen(new GameMenuScreen(true));
            }

        }
    }

    private void handleBlockBreaking(boolean breaking) {
        if (!breaking) {
            this.attackCooldown = 0;
        }

        if (this.attackCooldown <= 0 && !this.player.isUsingItem()) {
            if (breaking && this.crosshairTarget != null && this.crosshairTarget.getType() == net.minecraft.util.hit.HitResult.Type.BLOCK) {
                BlockHitResult blockHitResult = (BlockHitResult)this.crosshairTarget;
                BlockPos blockPos = blockHitResult.getBlockPos();
                if (!this.world.getBlockState(blockPos).isAir()) {
                    Direction direction = blockHitResult.getSide();
                    if (this.interactionManager.updateBlockBreakingProgress(blockPos, direction)) {
                        this.particleManager.addBlockBreakingParticles(blockPos, direction);
                        this.player.swingHand(Hand.MAIN_HAND);
                    }
                }

            } else {
                this.interactionManager.cancelBlockBreaking();
            }
        }
    }

    private boolean doAttack() {
        if (this.attackCooldown > 0) {
            return false;
        } else if (this.crosshairTarget == null) {
            LOGGER.error("Null returned as 'hitResult', this shouldn't happen!");
            if (this.interactionManager.hasLimitedAttackSpeed()) {
                this.attackCooldown = 10;
            }

            return false;
        } else if (this.player.isRiding()) {
            return false;
        } else {
            ItemStack itemStack = this.player.getStackInHand(Hand.MAIN_HAND);
            if (!itemStack.isItemEnabled(this.world.getEnabledFeatures())) {
                return false;
            } else {
                boolean bl = false;
                switch (this.crosshairTarget.getType()) {
                    case ENTITY:
                        this.interactionManager.attackEntity(this.player, ((EntityHitResult)this.crosshairTarget).getEntity());
                        break;
                    case BLOCK:
                        BlockHitResult blockHitResult = (BlockHitResult)this.crosshairTarget;
                        BlockPos blockPos = blockHitResult.getBlockPos();
                        if (!this.world.getBlockState(blockPos).isAir()) {
                            this.interactionManager.attackBlock(blockPos, blockHitResult.getSide());
                            if (this.world.getBlockState(blockPos).isAir()) {
                                bl = true;
                            }
                            break;
                        }
                    case MISS:
                        if (this.interactionManager.hasLimitedAttackSpeed()) {
                            this.attackCooldown = 10;
                        }

                        this.player.resetLastAttackedTicks();
                }

                this.player.swingHand(Hand.MAIN_HAND);
                return bl;
            }
        }
    }

    private void doItemUse() {
        if (!this.interactionManager.isBreakingBlock()) {
            this.itemUseCooldown = 4;
            if (!this.player.isRiding()) {
                if (this.crosshairTarget == null) {
                    LOGGER.warn("Null returned as 'hitResult', this shouldn't happen!");
                }

                for(Hand hand : Hand.values()) {
                    ItemStack itemStack = this.player.getStackInHand(hand);
                    if (!itemStack.isItemEnabled(this.world.getEnabledFeatures())) {
                        return;
                    }

                    if (this.crosshairTarget != null) {
                        switch (this.crosshairTarget.getType()) {
                            case ENTITY:
                                EntityHitResult entityHitResult = (EntityHitResult)this.crosshairTarget;
                                Entity entity = entityHitResult.getEntity();
                                if (!this.world.getWorldBorder().contains(entity.getBlockPos())) {
                                    return;
                                }

                                ActionResult actionResult = this.interactionManager.interactEntityAtLocation(this.player, entity, entityHitResult, hand);
                                if (!actionResult.isAccepted()) {
                                    actionResult = this.interactionManager.interactEntity(this.player, entity, hand);
                                }

                                if (actionResult instanceof ActionResult.Success) {
                                    ActionResult.Success success = (ActionResult.Success)actionResult;
                                    if (success.swingSource() == SwingSource.CLIENT) {
                                        this.player.swingHand(hand);
                                    }

                                    return;
                                }
                                break;
                            case BLOCK:
                                BlockHitResult blockHitResult = (BlockHitResult)this.crosshairTarget;
                                int i = itemStack.getCount();
                                ActionResult actionResult2 = this.interactionManager.interactBlock(this.player, hand, blockHitResult);
                                if (actionResult2 instanceof ActionResult.Success) {
                                    ActionResult.Success success2 = (ActionResult.Success)actionResult2;
                                    if (success2.swingSource() == SwingSource.CLIENT) {
                                        this.player.swingHand(hand);
                                        if (!itemStack.isEmpty() && (itemStack.getCount() != i || this.player.isInCreativeMode())) {
                                            this.gameRenderer.firstPersonRenderer.resetEquipProgress(hand);
                                        }
                                    }

                                    return;
                                }

                                if (actionResult2 instanceof ActionResult.Fail) {
                                    return;
                                }
                        }
                    }

                    if (!itemStack.isEmpty()) {
                        ActionResult actionResult3 = this.interactionManager.interactItem(this.player, hand);
                        if (actionResult3 instanceof ActionResult.Success) {
                            ActionResult.Success success3 = (ActionResult.Success)actionResult3;
                            if (success3.swingSource() == SwingSource.CLIENT) {
                                this.player.swingHand(hand);
                            }

                            this.gameRenderer.firstPersonRenderer.resetEquipProgress(hand);
                            return;
                        }
                    }
                }

            }
        }
    }

    public MusicTracker getMusicTracker() {
        return this.musicTracker;
    }

    public void tick() {
        ++this.uptimeInTicks;
        if (this.world != null && !this.paused) {
            this.world.getTickManager().step();
        }

        if (this.itemUseCooldown > 0) {
            --this.itemUseCooldown;
        }

        Profiler profiler = Profilers.get();
        profiler.push("gui");
        this.messageHandler.processDelayedMessages();
        this.inGameHud.tick(this.paused);
        profiler.pop();
        this.gameRenderer.updateCrosshairTarget(1.0F);
        this.tutorialManager.tick(this.world, this.crosshairTarget);
        profiler.push("gameMode");
        if (!this.paused && this.world != null) {
            this.interactionManager.tick();
        }

        profiler.swap("textures");
        if (this.shouldTick()) {
            this.textureManager.tick();
        }

        if (this.currentScreen == null && this.player != null) {
            if (this.player.isDead() && !(this.currentScreen instanceof DeathScreen)) {
                this.setScreen((Screen)null);
            } else if (this.player.isSleeping() && this.world != null) {
                this.setScreen(new SleepingChatScreen());
            }
        } else {
            Screen var3 = this.currentScreen;
            if (var3 instanceof SleepingChatScreen) {
                SleepingChatScreen sleepingChatScreen = (SleepingChatScreen)var3;
                if (!this.player.isSleeping()) {
                    sleepingChatScreen.closeChatIfEmpty();
                }
            }
        }

        if (this.currentScreen != null) {
            this.attackCooldown = 10000;
        }

        if (this.currentScreen != null) {
            try {
                this.currentScreen.tick();
            } catch (Throwable throwable) {
                CrashReport crashReport = CrashReport.create(throwable, "Ticking screen");
                this.currentScreen.addCrashReportSection(crashReport);
                throw new CrashException(crashReport);
            }
        }

        if (!this.getDebugHud().shouldShowDebugHud()) {
            this.inGameHud.resetDebugHudChunk();
        }

        if (this.overlay == null && this.currentScreen == null) {
            profiler.swap("Keybindings");
            this.handleInputEvents();
            if (this.attackCooldown > 0) {
                --this.attackCooldown;
            }
        }

        if (this.world != null) {
            profiler.swap("gameRenderer");
            if (!this.paused) {
                this.gameRenderer.tick();
            }

            profiler.swap("levelRenderer");
            if (!this.paused) {
                this.worldRenderer.tick();
            }

            profiler.swap("level");
            if (!this.paused) {
                this.world.tickEntities();
            }
        } else if (this.gameRenderer.getPostProcessorId() != null) {
            this.gameRenderer.clearPostProcessor();
        }

        this.musicTracker.tick();
        this.soundManager.tick(this.paused);
        if (this.world != null) {
            if (!this.paused) {
                if (!this.options.joinedFirstServer && this.isConnectedToServer()) {
                    Text text = Text.translatable("tutorial.socialInteractions.title");
                    Text text2 = Text.translatable("tutorial.socialInteractions.description", new Object[]{TutorialManager.keyToText("socialInteractions")});
                    this.socialInteractionsToast = new TutorialToast(this.textRenderer, net.minecraft.client.toast.TutorialToast.Type.SOCIAL_INTERACTIONS, text, text2, true, 8000);
                    this.toastManager.add(this.socialInteractionsToast);
                    this.options.joinedFirstServer = true;
                    this.options.write();
                }

                this.tutorialManager.tick();

                try {
                    this.world.tick(() -> true);
                } catch (Throwable throwable) {
                    CrashReport crashReport = CrashReport.create(throwable, "Exception in world tick");
                    if (this.world == null) {
                        CrashReportSection crashReportSection = crashReport.addElement("Affected level");
                        crashReportSection.add("Problem", "Level is null!");
                    } else {
                        this.world.addDetailsToCrashReport(crashReport);
                    }

                    throw new CrashException(crashReport);
                }
            }

            profiler.swap("animateTick");
            if (!this.paused && this.shouldTick()) {
                this.world.doRandomBlockDisplayTicks(this.player.getBlockX(), this.player.getBlockY(), this.player.getBlockZ());
            }

            profiler.swap("particles");
            if (!this.paused && this.shouldTick()) {
                this.particleManager.tick();
            }

            ClientPlayNetworkHandler clientPlayNetworkHandler = this.getNetworkHandler();
            if (clientPlayNetworkHandler != null && !this.paused) {
                clientPlayNetworkHandler.sendPacket(ClientTickEndC2SPacket.INSTANCE);
            }
        } else if (this.integratedServerConnection != null) {
            profiler.swap("pendingConnection");
            this.integratedServerConnection.tick();
        }

        profiler.swap("keyboard");
        this.keyboard.pollDebugCrash();
        profiler.pop();
    }

    private boolean shouldTick() {
        return this.world == null || this.world.getTickManager().shouldTick();
    }

    private boolean isConnectedToServer() {
        return !this.integratedServerRunning || this.server != null && this.server.isRemote();
    }

    private void handleInputEvents() {
        for(; this.options.togglePerspectiveKey.wasPressed(); this.worldRenderer.scheduleTerrainUpdate()) {
            Perspective perspective = this.options.getPerspective();
            this.options.setPerspective(this.options.getPerspective().next());
            if (perspective.isFirstPerson() != this.options.getPerspective().isFirstPerson()) {
                this.gameRenderer.onCameraEntitySet(this.options.getPerspective().isFirstPerson() ? this.getCameraEntity() : null);
            }
        }

        while(this.options.smoothCameraKey.wasPressed()) {
            this.options.smoothCameraEnabled = !this.options.smoothCameraEnabled;
        }

        for(int i = 0; i < 9; ++i) {
            boolean bl = this.options.saveToolbarActivatorKey.isPressed();
            boolean bl2 = this.options.loadToolbarActivatorKey.isPressed();
            if (this.options.hotbarKeys[i].wasPressed()) {
                if (this.player.isSpectator()) {
                    this.inGameHud.getSpectatorHud().selectSlot(i);
                } else if (!this.player.isInCreativeMode() || this.currentScreen != null || !bl2 && !bl) {
                    this.player.getInventory().setSelectedSlot(i);
                } else {
                    CreativeInventoryScreen.onHotbarKeyPress(this, i, bl2, bl);
                }
            }
        }

        while(this.options.socialInteractionsKey.wasPressed()) {
            if (!this.isConnectedToServer()) {
                this.player.sendMessage(SOCIAL_INTERACTIONS_NOT_AVAILABLE, true);
                this.narratorManager.narrateSystemImmediately(SOCIAL_INTERACTIONS_NOT_AVAILABLE);
            } else {
                if (this.socialInteractionsToast != null) {
                    this.socialInteractionsToast.hide();
                    this.socialInteractionsToast = null;
                }

                this.setScreen(new SocialInteractionsScreen());
            }
        }

        while(this.options.inventoryKey.wasPressed()) {
            if (this.interactionManager.hasRidingInventory()) {
                this.player.openRidingInventory();
            } else {
                this.tutorialManager.onInventoryOpened();
                this.setScreen(new InventoryScreen(this.player));
            }
        }

        while(this.options.advancementsKey.wasPressed()) {
            this.setScreen(new AdvancementsScreen(this.player.networkHandler.getAdvancementHandler()));
        }

        while(this.options.quickActionsKey.wasPressed()) {
            this.getQuickActionsDialog().ifPresent((dialog) -> this.player.networkHandler.showDialog(dialog, this.currentScreen));
        }

        while(this.options.swapHandsKey.wasPressed()) {
            if (!this.player.isSpectator()) {
                this.getNetworkHandler().sendPacket(new PlayerActionC2SPacket(Action.SWAP_ITEM_WITH_OFFHAND, BlockPos.ORIGIN, Direction.DOWN));
            }
        }

        while(this.options.dropKey.wasPressed()) {
            if (!this.player.isSpectator() && this.player.dropSelectedItem(Screen.hasControlDown())) {
                this.player.swingHand(Hand.MAIN_HAND);
            }
        }

        while(this.options.chatKey.wasPressed()) {
            this.openChatScreen("");
        }

        if (this.currentScreen == null && this.overlay == null && this.options.commandKey.wasPressed()) {
            this.openChatScreen("/");
        }

        boolean bl3 = false;
        if (this.player.isUsingItem()) {
            if (!this.options.useKey.isPressed()) {
                this.interactionManager.stopUsingItem(this.player);
            }

            while(this.options.attackKey.wasPressed()) {
            }

            while(this.options.useKey.wasPressed()) {
            }

            while(this.options.pickItemKey.wasPressed()) {
            }
        } else {
            while(this.options.attackKey.wasPressed()) {
                bl3 |= this.doAttack();
            }

            while(this.options.useKey.wasPressed()) {
                this.doItemUse();
            }

            while(this.options.pickItemKey.wasPressed()) {
                this.doItemPick();
            }
        }

        if (this.options.useKey.isPressed() && this.itemUseCooldown == 0 && !this.player.isUsingItem()) {
            this.doItemUse();
        }

        this.handleBlockBreaking(this.currentScreen == null && !bl3 && this.options.attackKey.isPressed() && this.mouse.isCursorLocked());
    }

    private Optional<RegistryEntry<Dialog>> getQuickActionsDialog() {
        Registry<Dialog> registry = this.player.networkHandler.getRegistryManager().getOrThrow(RegistryKeys.DIALOG);
        return registry.getOptional(DialogTags.QUICK_ACTIONS).flatMap((quickActionsDialogs) -> {
            if (quickActionsDialogs.size() == 0) {
                return Optional.empty();
            } else {
                return quickActionsDialogs.size() == 1 ? Optional.of(quickActionsDialogs.get(0)) : registry.getOptional(Dialogs.QUICK_ACTIONS);
            }
        });
    }

    public TelemetryManager getTelemetryManager() {
        return this.telemetryManager;
    }

    public double getGpuUtilizationPercentage() {
        return this.gpuUtilizationPercentage;
    }

    public ProfileKeys getProfileKeys() {
        return this.profileKeys;
    }

    public IntegratedServerLoader createIntegratedServerLoader() {
        return new IntegratedServerLoader(this, this.levelStorage);
    }

    public void startIntegratedServer(LevelStorage.Session session, ResourcePackManager dataPackManager, SaveLoader saveLoader, boolean newWorld) {
        this.disconnectWithProgressScreen();
        this.worldGenProgressTracker.set((Object)null);
        Instant instant = Instant.now();

        try {
            session.backupLevelDataFile(saveLoader.combinedDynamicRegistries().getCombinedRegistryManager(), saveLoader.saveProperties());
            ApiServices apiServices = ApiServices.create(this.authenticationService, this.runDirectory);
            apiServices.userCache().setExecutor(this);
            SkullBlockEntity.setServices(apiServices, this);
            UserCache.setUseRemote(false);
            this.server = (IntegratedServer)MinecraftServer.startServer((thread) -> new IntegratedServer(thread, this, session, dataPackManager, saveLoader, apiServices, (spawnChunkRadius) -> {
                    WorldGenerationProgressTracker worldGenerationProgressTracker = WorldGenerationProgressTracker.create(spawnChunkRadius + 0);
                    this.worldGenProgressTracker.set(worldGenerationProgressTracker);
                    Queue var10001 = this.renderTaskQueue;
                    Objects.requireNonNull(var10001);
                    return QueueingWorldGenerationProgressListener.create(worldGenerationProgressTracker, var10001::add);
                }));
            this.integratedServerRunning = true;
            this.ensureAbuseReportContext(ReporterEnvironment.ofIntegratedServer());
            this.quickPlayLogger.setWorld(WorldType.SINGLEPLAYER, session.getDirectoryName(), saveLoader.saveProperties().getLevelName());
        } catch (Throwable throwable) {
            CrashReport crashReport = CrashReport.create(throwable, "Starting integrated server");
            CrashReportSection crashReportSection = crashReport.addElement("Starting integrated server");
            crashReportSection.add("Level ID", session.getDirectoryName());
            crashReportSection.add("Level Name", () -> saveLoader.saveProperties().getLevelName());
            throw new CrashException(crashReport);
        }

        while(this.worldGenProgressTracker.get() == null) {
            Thread.yield();
        }

        LevelLoadingScreen levelLoadingScreen = new LevelLoadingScreen((WorldGenerationProgressTracker)this.worldGenProgressTracker.get());
        Profiler profiler = Profilers.get();
        this.setScreen(levelLoadingScreen);
        profiler.push("waitForServer");

        for(; !this.server.isLoading() || this.overlay != null; this.printCrashReport()) {
            levelLoadingScreen.tick();
            this.render(false);

            try {
                Thread.sleep(16L);
            } catch (InterruptedException var11) {
            }
        }

        TestManager.INSTANCE.startTicking();
        profiler.pop();
        Duration duration = Duration.between(instant, Instant.now());
        SocketAddress socketAddress = this.server.getNetworkIo().bindLocal();
        ClientConnection clientConnection = ClientConnection.connectLocal(socketAddress);
        clientConnection.connect(socketAddress.toString(), 0, new ClientLoginNetworkHandler(clientConnection, this, (ServerInfo)null, (Screen)null, newWorld, duration, (status) -> {
        }, (CookieStorage)null));
        clientConnection.send(new LoginHelloC2SPacket(this.getSession().getUsername(), this.getSession().getUuidOrNull()));
        this.integratedServerConnection = clientConnection;
    }

    public void joinWorld(ClientWorld world, DownloadingTerrainScreen.WorldEntryReason worldEntryReason) {
        this.reset(new DownloadingTerrainScreen(() -> false, worldEntryReason));
        this.world = world;
        this.setWorld(world);
        if (!this.integratedServerRunning) {
            ApiServices apiServices = ApiServices.create(this.authenticationService, this.runDirectory);
            apiServices.userCache().setExecutor(this);
            SkullBlockEntity.setServices(apiServices, this);
            UserCache.setUseRemote(false);
        }

    }

    public void disconnectWithSavingScreen() {
        this.disconnect(new MessageScreen(SAVING_LEVEL_TEXT), false);
    }

    public void disconnectWithProgressScreen() {
        this.disconnect(new ProgressScreen(true), false);
    }

    public void disconnect(Screen disconnectionScreen, boolean transferring) {
        ClientPlayNetworkHandler clientPlayNetworkHandler = this.getNetworkHandler();
        if (clientPlayNetworkHandler != null) {
            this.cancelTasks();
            clientPlayNetworkHandler.unloadWorld();
            if (!transferring) {
                this.onDisconnected();
            }
        }

        this.socialInteractionsManager.unloadBlockList();
        if (this.recorder.isActive()) {
            this.forceStopRecorder();
        }

        IntegratedServer integratedServer = this.server;
        this.server = null;
        this.gameRenderer.reset();
        this.interactionManager = null;
        this.narratorManager.clear();
        this.disconnecting = true;

        try {
            this.reset(disconnectionScreen);
            if (this.world != null) {
                if (integratedServer != null) {
                    Profiler profiler = Profilers.get();
                    profiler.push("waitForServer");

                    while(!integratedServer.isStopping()) {
                        this.render(false);
                    }

                    profiler.pop();
                }

                this.inGameHud.clear();
                this.integratedServerRunning = false;
            }

            this.world = null;
            this.setWorld((ClientWorld)null);
            this.player = null;
        } finally {
            this.disconnecting = false;
        }

        SkullBlockEntity.clearServices();
    }

    public void onDisconnected() {
        this.serverResourcePackLoader.clear();
        this.runTasks();
    }

    public void enterReconfiguration(Screen reconfigurationScreen) {
        ClientPlayNetworkHandler clientPlayNetworkHandler = this.getNetworkHandler();
        if (clientPlayNetworkHandler != null) {
            clientPlayNetworkHandler.clearWorld();
        }

        if (this.recorder.isActive()) {
            this.forceStopRecorder();
        }

        this.gameRenderer.reset();
        this.interactionManager = null;
        this.narratorManager.clear();
        this.disconnecting = true;

        try {
            this.reset(reconfigurationScreen);
            this.inGameHud.clear();
            this.world = null;
            this.setWorld((ClientWorld)null);
            this.player = null;
        } finally {
            this.disconnecting = false;
        }

        SkullBlockEntity.clearServices();
    }

    private void reset(Screen resettingScreen) {
        Profiler profiler = Profilers.get();
        profiler.push("forcedTick");
        this.soundManager.stopAll();
        this.cameraEntity = null;
        this.integratedServerConnection = null;
        this.setScreen(resettingScreen);
        this.render(false);
        profiler.pop();
    }

    public void setScreenAndRender(Screen screen) {
        try (ScopedProfiler scopedProfiler = Profilers.get().scoped("forcedTick")) {
            this.setScreen(screen);
            this.render(false);
        }

    }

    private void setWorld(@Nullable ClientWorld world) {
        this.worldRenderer.setWorld(world);
        this.particleManager.setWorld(world);
        this.blockEntityRenderDispatcher.setWorld(world);
        this.gameRenderer.setWorld(world);
        this.updateWindowTitle();
    }

    private UserApiService.UserProperties getUserProperties() {
        return (UserApiService.UserProperties)this.userPropertiesFuture.join();
    }

    public boolean isOptionalTelemetryEnabled() {
        return this.isOptionalTelemetryEnabledByApi() && (Boolean)this.options.getTelemetryOptInExtra().getValue();
    }

    public boolean isOptionalTelemetryEnabledByApi() {
        return this.isTelemetryEnabledByApi() && this.getUserProperties().flag(UserFlag.OPTIONAL_TELEMETRY_AVAILABLE);
    }

    public boolean isTelemetryEnabledByApi() {
        return SharedConstants.isDevelopment ? false : this.getUserProperties().flag(UserFlag.TELEMETRY_ENABLED);
    }

    public boolean isMultiplayerEnabled() {
        return this.multiplayerEnabled && this.getUserProperties().flag(UserFlag.SERVERS_ALLOWED) && this.getMultiplayerBanDetails() == null && !this.isUsernameBanned();
    }

    public boolean isRealmsEnabled() {
        return this.getUserProperties().flag(UserFlag.REALMS_ALLOWED) && this.getMultiplayerBanDetails() == null;
    }

    @Nullable
    public BanDetails getMultiplayerBanDetails() {
        return (BanDetails)this.getUserProperties().bannedScopes().get("MULTIPLAYER");
    }

    public boolean isUsernameBanned() {
        com.mojang.authlib.yggdrasil.ProfileResult profileResult = (com.mojang.authlib.yggdrasil.ProfileResult)this.gameProfileFuture.getNow((Object)null);
        return profileResult != null && profileResult.actions().contains(ProfileActionType.FORCED_NAME_CHANGE);
    }

    public boolean shouldBlockMessages(UUID sender) {
        if (this.getChatRestriction().allowsChat(false)) {
            return this.socialInteractionsManager.isPlayerMuted(sender);
        } else {
            return (this.player == null || !sender.equals(this.player.getUuid())) && !sender.equals(Util.NIL_UUID);
        }
    }

    public ChatRestriction getChatRestriction() {
        if (this.options.getChatVisibility().getValue() == ChatVisibility.HIDDEN) {
            return MinecraftClient.ChatRestriction.DISABLED_BY_OPTIONS;
        } else if (!this.onlineChatEnabled) {
            return MinecraftClient.ChatRestriction.DISABLED_BY_LAUNCHER;
        } else {
            return !this.getUserProperties().flag(UserFlag.CHAT_ALLOWED) ? MinecraftClient.ChatRestriction.DISABLED_BY_PROFILE : MinecraftClient.ChatRestriction.ENABLED;
        }
    }

    public final boolean isDemo() {
        return this.isDemo;
    }

    @Nullable
    public ClientPlayNetworkHandler getNetworkHandler() {
        return this.player == null ? null : this.player.networkHandler;
    }

    public static boolean isHudEnabled() {
        return !instance.options.hudHidden;
    }

    public static boolean isFancyGraphicsOrBetter() {
        return ((GraphicsMode)instance.options.getGraphicsMode().getValue()).getId() >= GraphicsMode.FANCY.getId();
    }

    public static boolean isFabulousGraphicsOrBetter() {
        return !instance.gameRenderer.isRenderingPanorama() && ((GraphicsMode)instance.options.getGraphicsMode().getValue()).getId() >= GraphicsMode.FABULOUS.getId();
    }

    public static boolean isAmbientOcclusionEnabled() {
        return (Boolean)instance.options.getAo().getValue();
    }

    private void doItemPick() {
        if (this.crosshairTarget != null && this.crosshairTarget.getType() != net.minecraft.util.hit.HitResult.Type.MISS) {
            boolean bl = Screen.hasControlDown();
            HitResult var10000 = this.crosshairTarget;
            Objects.requireNonNull(var10000);
            HitResult var2 = var10000;
            byte var3 = 0;
            //$FF: var3->value
            //0->net/minecraft/util/hit/BlockHitResult
            //1->net/minecraft/util/hit/EntityHitResult
            switch (var2.typeSwitch<invokedynamic>(var2, var3)) {
                case 0:
                    BlockHitResult blockHitResult = (BlockHitResult)var2;
                    this.interactionManager.pickItemFromBlock(blockHitResult.getBlockPos(), bl);
                    break;
                case 1:
                    EntityHitResult entityHitResult = (EntityHitResult)var2;
                    this.interactionManager.pickItemFromEntity(entityHitResult.getEntity(), bl);
            }

        }
    }

    public CrashReport addDetailsToCrashReport(CrashReport report) {
        SystemDetails systemDetails = report.getSystemDetailsSection();

        try {
            addSystemDetailsToCrashReport(systemDetails, this, this.languageManager, this.gameVersion, this.options);
            this.addUptimesToCrashReport(report.addElement("Uptime"));
            if (this.world != null) {
                this.world.addDetailsToCrashReport(report);
            }

            if (this.server != null) {
                this.server.addSystemDetails(systemDetails);
            }

            this.resourceReloadLogger.addReloadSection(report);
        } catch (Throwable throwable) {
            LOGGER.error("Failed to collect details", throwable);
        }

        return report;
    }

    public static void addSystemDetailsToCrashReport(@Nullable MinecraftClient client, @Nullable LanguageManager languageManager, String version, @Nullable GameOptions options, CrashReport report) {
        SystemDetails systemDetails = report.getSystemDetailsSection();
        addSystemDetailsToCrashReport(systemDetails, client, languageManager, version, options);
    }

    private static String formatSeconds(double seconds) {
        return String.format(Locale.ROOT, "%.3fs", seconds);
    }

    private void addUptimesToCrashReport(CrashReportSection section) {
        section.add("JVM uptime", () -> formatSeconds((double)ManagementFactory.getRuntimeMXBean().getUptime() / (double)1000.0F));
        section.add("Wall uptime", () -> formatSeconds((double)(System.currentTimeMillis() - this.startTime) / (double)1000.0F));
        section.add("High-res time", () -> formatSeconds((double)Util.getMeasuringTimeMs() / (double)1000.0F));
        section.add("Client ticks", () -> String.format(Locale.ROOT, "%d ticks / %.3fs", this.uptimeInTicks, (double)this.uptimeInTicks / (double)20.0F));
    }

    private static SystemDetails addSystemDetailsToCrashReport(SystemDetails systemDetails, @Nullable MinecraftClient client, @Nullable LanguageManager languageManager, String version, @Nullable GameOptions options) {
        systemDetails.addSection("Launched Version", () -> version);
        String string = getLauncherBrand();
        if (string != null) {
            systemDetails.addSection("Launcher name", string);
        }

        systemDetails.addSection("Backend library", RenderSystem::getBackendDescription);
        systemDetails.addSection("Backend API", RenderSystem::getApiDescription);
        systemDetails.addSection("Window size", () -> client != null ? client.window.getFramebufferWidth() + "x" + client.window.getFramebufferHeight() : "<not initialized>");
        systemDetails.addSection("GFLW Platform", Window::getGlfwPlatform);
        systemDetails.addSection("Render Extensions", () -> String.join(", ", RenderSystem.getDevice().getEnabledExtensions()));
        systemDetails.addSection("GL debug messages", () -> {
            GpuDevice gpuDevice = RenderSystem.tryGetDevice();
            if (gpuDevice == null) {
                return "<no renderer available>";
            } else {
                return gpuDevice.isDebuggingEnabled() ? String.join("\n", gpuDevice.getLastDebugMessages()) : "<debugging unavailable>";
            }
        });
        systemDetails.addSection("Is Modded", () -> getModStatus().getMessage());
        systemDetails.addSection("Universe", () -> client != null ? Long.toHexString(client.UNIVERSE) : "404");
        systemDetails.addSection("Type", "Client (map_client.txt)");
        if (options != null) {
            if (client != null) {
                String string2 = client.getVideoWarningManager().getWarningsAsString();
                if (string2 != null) {
                    systemDetails.addSection("GPU Warnings", string2);
                }
            }

            systemDetails.addSection("Graphics mode", ((GraphicsMode)options.getGraphicsMode().getValue()).toString());
            int var10002 = options.getClampedViewDistance();
            systemDetails.addSection("Render Distance", var10002 + "/" + String.valueOf(options.getViewDistance().getValue()) + " chunks");
        }

        if (client != null) {
            systemDetails.addSection("Resource Packs", () -> ResourcePackManager.listPacks(client.getResourcePackManager().getEnabledProfiles()));
        }

        if (languageManager != null) {
            systemDetails.addSection("Current Language", () -> languageManager.getLanguage());
        }

        systemDetails.addSection("Locale", String.valueOf(Locale.getDefault()));
        systemDetails.addSection("System encoding", () -> System.getProperty("sun.jnu.encoding", "<not set>"));
        systemDetails.addSection("File encoding", () -> System.getProperty("file.encoding", "<not set>"));
        systemDetails.addSection("CPU", GLX::_getCpuInfo);
        return systemDetails;
    }

    public static MinecraftClient getInstance() {
        return instance;
    }

    public CompletableFuture<Void> reloadResourcesConcurrently() {
        return this.submit(this::reloadResources).thenCompose((future) -> future);
    }

    public void ensureAbuseReportContext(ReporterEnvironment environment) {
        if (!this.abuseReportContext.environmentEquals(environment)) {
            this.abuseReportContext = AbuseReportContext.create(environment, this.userApiService);
        }

    }

    @Nullable
    public ServerInfo getCurrentServerEntry() {
        return (ServerInfo)Nullables.map(this.getNetworkHandler(), ClientPlayNetworkHandler::getServerInfo);
    }

    public boolean isInSingleplayer() {
        return this.integratedServerRunning;
    }

    public boolean isIntegratedServerRunning() {
        return this.integratedServerRunning && this.server != null;
    }

    @Nullable
    public IntegratedServer getServer() {
        return this.server;
    }

    public boolean isConnectedToLocalServer() {
        IntegratedServer integratedServer = this.getServer();
        return integratedServer != null && !integratedServer.isRemote();
    }

    public boolean uuidEquals(UUID uuid) {
        return uuid.equals(this.getSession().getUuidOrNull());
    }

    public Session getSession() {
        return this.session;
    }

    public GameProfile getGameProfile() {
        com.mojang.authlib.yggdrasil.ProfileResult profileResult = (com.mojang.authlib.yggdrasil.ProfileResult)this.gameProfileFuture.join();
        return profileResult != null ? profileResult.profile() : new GameProfile(this.session.getUuidOrNull(), this.session.getUsername());
    }

    public Proxy getNetworkProxy() {
        return this.networkProxy;
    }

    public TextureManager getTextureManager() {
        return this.textureManager;
    }

    public ShaderLoader getShaderLoader() {
        return this.shaderLoader;
    }

    public ResourceManager getResourceManager() {
        return this.resourceManager;
    }

    public ResourcePackManager getResourcePackManager() {
        return this.resourcePackManager;
    }

    public DefaultResourcePack getDefaultResourcePack() {
        return this.defaultResourcePack;
    }

    public ServerResourcePackLoader getServerResourcePackProvider() {
        return this.serverResourcePackLoader;
    }

    public Path getResourcePackDir() {
        return this.resourcePackDir;
    }

    public LanguageManager getLanguageManager() {
        return this.languageManager;
    }

    public Function<Identifier, Sprite> getSpriteAtlas(Identifier id) {
        SpriteAtlasTexture var10000 = this.bakedModelManager.getAtlas(id);
        Objects.requireNonNull(var10000);
        return var10000::getSprite;
    }

    public boolean isPaused() {
        return this.paused;
    }

    public VideoWarningManager getVideoWarningManager() {
        return this.videoWarningManager;
    }

    public SoundManager getSoundManager() {
        return this.soundManager;
    }

    public MusicInstance getMusicInstance() {
        MusicSound musicSound = (MusicSound)Nullables.map(this.currentScreen, Screen::getMusic);
        if (musicSound != null) {
            return new MusicInstance(musicSound);
        } else if (this.player == null) {
            return new MusicInstance(MusicType.MENU);
        } else {
            World world = this.player.getWorld();
            if (world.getRegistryKey() == World.END) {
                return this.inGameHud.getBossBarHud().shouldPlayDragonMusic() ? new MusicInstance(MusicType.DRAGON) : new MusicInstance(MusicType.END);
            } else {
                RegistryEntry<Biome> registryEntry = world.getBiome(this.player.getBlockPos());
                Biome biome = (Biome)registryEntry.value();
                float f = biome.getMusicVolume();
                Optional<Pool<MusicSound>> optional = biome.getMusic();
                if (optional.isPresent()) {
                    Optional<MusicSound> optional2 = ((Pool)optional.get()).getOrEmpty(world.random);
                    return new MusicInstance((MusicSound)optional2.orElse((Object)null), f);
                } else if (!this.musicTracker.isPlayingType(MusicType.UNDERWATER) && (!this.player.isSubmergedInWater() || !registryEntry.isIn(BiomeTags.PLAYS_UNDERWATER_MUSIC))) {
                    return world.getRegistryKey() != World.NETHER && this.player.getAbilities().creativeMode && this.player.getAbilities().allowFlying ? new MusicInstance(MusicType.CREATIVE, f) : new MusicInstance(MusicType.GAME, f);
                } else {
                    return new MusicInstance(MusicType.UNDERWATER, f);
                }
            }
        }
    }

    public MinecraftSessionService getSessionService() {
        return this.sessionService;
    }

    public PlayerSkinProvider getSkinProvider() {
        return this.skinProvider;
    }

    @Nullable
    public Entity getCameraEntity() {
        return this.cameraEntity;
    }

    public void setCameraEntity(Entity entity) {
        this.cameraEntity = entity;
        this.gameRenderer.onCameraEntitySet(entity);
    }

    public boolean hasOutline(Entity entity) {
        return entity.isGlowing() || this.player != null && this.player.isSpectator() && this.options.spectatorOutlinesKey.isPressed() && entity.getType() == EntityType.PLAYER;
    }

    protected Thread getThread() {
        return this.thread;
    }

    public Runnable createTask(Runnable runnable) {
        return runnable;
    }

    protected boolean canExecute(Runnable task) {
        return true;
    }

    public BlockRenderManager getBlockRenderManager() {
        return this.blockRenderManager;
    }

    public EntityRenderDispatcher getEntityRenderDispatcher() {
        return this.entityRenderDispatcher;
    }

    public BlockEntityRenderDispatcher getBlockEntityRenderDispatcher() {
        return this.blockEntityRenderDispatcher;
    }

    public ItemRenderer getItemRenderer() {
        return this.itemRenderer;
    }

    public MapRenderer getMapRenderer() {
        return this.mapRenderer;
    }

    public DataFixer getDataFixer() {
        return this.dataFixer;
    }

    public RenderTickCounter getRenderTickCounter() {
        return this.renderTickCounter;
    }

    public BlockColors getBlockColors() {
        return this.blockColors;
    }

    public boolean hasReducedDebugInfo() {
        return this.player != null && this.player.hasReducedDebugInfo() || (Boolean)this.options.getReducedDebugInfo().getValue();
    }

    public ToastManager getToastManager() {
        return this.toastManager;
    }

    public TutorialManager getTutorialManager() {
        return this.tutorialManager;
    }

    public boolean isWindowFocused() {
        return this.windowFocused;
    }

    public HotbarStorage getCreativeHotbarStorage() {
        return this.creativeHotbarStorage;
    }

    public BakedModelManager getBakedModelManager() {
        return this.bakedModelManager;
    }

    public PaintingManager getPaintingManager() {
        return this.paintingManager;
    }

    public MapTextureManager getMapTextureManager() {
        return this.mapTextureManager;
    }

    public MapDecorationsAtlasManager getMapDecorationsAtlasManager() {
        return this.mapDecorationsAtlasManager;
    }

    public GuiAtlasManager getGuiAtlasManager() {
        return this.guiAtlasManager;
    }

    public WaypointStyleAssetManager getWaypointStyleAssetManager() {
        return this.waypointStyleAssetManager;
    }

    public void onWindowFocusChanged(boolean focused) {
        this.windowFocused = focused;
    }

    public Text takePanorama(File directory) {
        int i = 4;
        int j = 4096;
        int k = 4096;
        int l = this.window.getFramebufferWidth();
        int m = this.window.getFramebufferHeight();
        Framebuffer framebuffer = this.getFramebuffer();
        float f = this.player.getPitch();
        float g = this.player.getYaw();
        float h = this.player.lastPitch;
        float n = this.player.lastYaw;
        this.gameRenderer.setBlockOutlineEnabled(false);

        MutableText var13;
        try {
            this.gameRenderer.setRenderingPanorama(true);
            this.window.setFramebufferWidth(4096);
            this.window.setFramebufferHeight(4096);
            framebuffer.resize(4096, 4096);

            for(int o = 0; o < 6; ++o) {
                switch (o) {
                    case 0:
                        this.player.setYaw(g);
                        this.player.setPitch(0.0F);
                        break;
                    case 1:
                        this.player.setYaw((g + 90.0F) % 360.0F);
                        this.player.setPitch(0.0F);
                        break;
                    case 2:
                        this.player.setYaw((g + 180.0F) % 360.0F);
                        this.player.setPitch(0.0F);
                        break;
                    case 3:
                        this.player.setYaw((g - 90.0F) % 360.0F);
                        this.player.setPitch(0.0F);
                        break;
                    case 4:
                        this.player.setYaw(g);
                        this.player.setPitch(-90.0F);
                        break;
                    case 5:
                    default:
                        this.player.setYaw(g);
                        this.player.setPitch(90.0F);
                }

                this.player.lastYaw = this.player.getYaw();
                this.player.lastPitch = this.player.getPitch();
                this.gameRenderer.renderWorld(RenderTickCounter.ONE);

                try {
                    Thread.sleep(10L);
                } catch (InterruptedException var18) {
                }

                ScreenshotRecorder.saveScreenshot(directory, "panorama_" + o + ".png", framebuffer, 4, (message) -> {
                });
            }

            Text text = Text.literal(directory.getName()).formatted(Formatting.UNDERLINE).styled((style) -> style.withClickEvent(new ClickEvent.OpenFile(directory.getAbsoluteFile())));
            var13 = Text.translatable("screenshot.success", new Object[]{text});
            return var13;
        } catch (Exception exception) {
            LOGGER.error("Couldn't save image", exception);
            var13 = Text.translatable("screenshot.failure", new Object[]{exception.getMessage()});
        } finally {
            this.player.setPitch(f);
            this.player.setYaw(g);
            this.player.lastPitch = h;
            this.player.lastYaw = n;
            this.gameRenderer.setBlockOutlineEnabled(true);
            this.window.setFramebufferWidth(l);
            this.window.setFramebufferHeight(m);
            framebuffer.resize(l, m);
            this.gameRenderer.setRenderingPanorama(false);
        }

        return var13;
    }

    @Nullable
    public WorldGenerationProgressTracker getWorldGenerationProgressTracker() {
        return (WorldGenerationProgressTracker)this.worldGenProgressTracker.get();
    }

    public SplashTextResourceSupplier getSplashTextLoader() {
        return this.splashTextLoader;
    }

    @Nullable
    public Overlay getOverlay() {
        return this.overlay;
    }

    public SocialInteractionsManager getSocialInteractionsManager() {
        return this.socialInteractionsManager;
    }

    public Window getWindow() {
        return this.window;
    }

    public InactivityFpsLimiter getInactivityFpsLimiter() {
        return this.inactivityFpsLimiter;
    }

    public DebugHud getDebugHud() {
        return this.inGameHud.getDebugHud();
    }

    public BufferBuilderStorage getBufferBuilders() {
        return this.bufferBuilders;
    }

    public void setMipmapLevels(int mipmapLevels) {
        this.bakedModelManager.setMipmapLevels(mipmapLevels);
    }

    public LoadedEntityModels getLoadedEntityModels() {
        return (LoadedEntityModels)this.bakedModelManager.getEntityModelsSupplier().get();
    }

    public boolean shouldFilterText() {
        return this.getUserProperties().flag(UserFlag.PROFANITY_FILTER_ENABLED);
    }

    public void loadBlockList() {
        this.socialInteractionsManager.loadBlockList();
        this.getProfileKeys().fetchKeyPair();
    }

    @Nullable
    public SignatureVerifier getServicesSignatureVerifier() {
        return SignatureVerifier.create(this.authenticationService.getServicesKeySet(), ServicesKeyType.PROFILE_KEY);
    }

    public boolean providesProfileKeys() {
        return !this.authenticationService.getServicesKeySet().keys(ServicesKeyType.PROFILE_KEY).isEmpty();
    }

    public GuiNavigationType getNavigationType() {
        return this.navigationType;
    }

    public void setNavigationType(GuiNavigationType navigationType) {
        this.navigationType = navigationType;
    }

    public NarratorManager getNarratorManager() {
        return this.narratorManager;
    }

    public MessageHandler getMessageHandler() {
        return this.messageHandler;
    }

    public AbuseReportContext getAbuseReportContext() {
        return this.abuseReportContext;
    }

    public RealmsPeriodicCheckers getRealmsPeriodicCheckers() {
        return this.realmsPeriodicCheckers;
    }

    public QuickPlayLogger getQuickPlayLogger() {
        return this.quickPlayLogger;
    }

    public CommandHistoryManager getCommandHistoryManager() {
        return this.commandHistoryManager;
    }

    public SymlinkFinder getSymlinkFinder() {
        return this.symlinkFinder;
    }

    private float getTargetMillisPerTick(float millis) {
        if (this.world != null) {
            TickManager tickManager = this.world.getTickManager();
            if (tickManager.shouldTick()) {
                return Math.max(millis, tickManager.getMillisPerTick());
            }
        }

        return millis;
    }

    public ItemModelManager getItemModelManager() {
        return this.itemModelManager;
    }

    @Nullable
    public static String getLauncherBrand() {
        return System.getProperty("minecraft.launcher.brand");
    }

    static {
        IS_SYSTEM_MAC = Util.getOperatingSystem() == OperatingSystem.OSX;
        DEFAULT_FONT_ID = Identifier.ofVanilla("default");
        UNICODE_FONT_ID = Identifier.ofVanilla("uniform");
        ALT_TEXT_RENDERER_ID = Identifier.ofVanilla("alt");
        REGIONAL_COMPLIANCIES_ID = Identifier.ofVanilla("regional_compliancies.json");
        COMPLETED_UNIT_FUTURE = CompletableFuture.completedFuture(Unit.INSTANCE);
        SOCIAL_INTERACTIONS_NOT_AVAILABLE = Text.translatable("multiplayer.socialInteractions.not_available");
        SAVING_LEVEL_TEXT = Text.translatable("menu.savingLevel");
    }

    @Environment(EnvType.CLIENT)
    public static enum ChatRestriction {
        ENABLED(ScreenTexts.EMPTY) {
            public boolean allowsChat(boolean singlePlayer) {
                return true;
            }
        },
        DISABLED_BY_OPTIONS(Text.translatable("chat.disabled.options").formatted(Formatting.RED)) {
            public boolean allowsChat(boolean singlePlayer) {
                return false;
            }
        },
        DISABLED_BY_LAUNCHER(Text.translatable("chat.disabled.launcher").formatted(Formatting.RED)) {
            public boolean allowsChat(boolean singlePlayer) {
                return singlePlayer;
            }
        },
        DISABLED_BY_PROFILE(Text.translatable("chat.disabled.profile", new Object[]{Text.keybind(MinecraftClient.instance.options.chatKey.getTranslationKey())}).formatted(Formatting.RED)) {
            public boolean allowsChat(boolean singlePlayer) {
                return singlePlayer;
            }
        };

        static final Text MORE_INFO_TEXT = Text.translatable("chat.disabled.profile.moreInfo");
        private final Text description;

        ChatRestriction(final Text description) {
            this.description = description;
        }

        public Text getDescription() {
            return this.description;
        }

        public abstract boolean allowsChat(boolean singlePlayer);
    }

    @Environment(EnvType.CLIENT)
    static record LoadingContext(RealmsClient realmsClient, RunArgs.QuickPlay quickPlayData) {
        final RunArgs.QuickPlay quickPlayData;
    }
}

Event.class:

/*
 * Copyright (c) 2016, 2017, 2018, 2019 FabricMC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package net.fabricmc.fabric.api.event;

import net.minecraft.util.Identifier;
import org.jetbrains.annotations.ApiStatus;

/**
 * Base class for Fabric's event implementations.
 *
 * @param <T> The listener type.
 * @see EventFactory
 */
@ApiStatus.NonExtendable // Should only be extended by fabric API.
public abstract class Event<T> {
	/**
	 * The invoker field. This should be updated by the implementation to
	 * always refer to an instance containing all code that should be
	 * executed upon event emission.
	 */
	protected volatile T invoker;

	/**
	 * Returns the invoker instance.
	 *
	 * <p>An "invoker" is an object which hides multiple registered
	 * listeners of type T under one instance of type T, executing
	 * them and leaving early as necessary.
	 *
	 * @return The invoker instance.
	 */
	public final T invoker() {
		return invoker;
	}

	/**
	 * Register a listener to the event, in the default phase.
	 * Have a look at {@link #addPhaseOrdering} for an explanation of event phases.
	 *
	 * @param listener The desired listener.
	 */
	public abstract void register(T listener);

	/**
	 * The identifier of the default phase.
	 * Have a look at {@link EventFactory#createWithPhases} for an explanation of event phases.
	 */
	public static final Identifier DEFAULT_PHASE = Identifier.of("fabric", "default");

	/**
	 * Register a listener to the event for the specified phase.
	 * Have a look at {@link EventFactory#createWithPhases} for an explanation of event phases.
	 *
	 * @param phase Identifier of the phase this listener should be registered for. It will be created if it didn't exist yet.
	 * @param listener The desired listener.
	 */
	public void register(Identifier phase, T listener) {
		// This is done to keep compatibility with existing Event subclasses, but they should really not be subclassing Event.
		register(listener);
	}

	/**
	 * Request that listeners registered for one phase be executed before listeners registered for another phase.
	 * Relying on the default phases supplied to {@link EventFactory#createWithPhases} should be preferred over manually
	 * registering phase ordering dependencies.
	 *
	 * <p>Incompatible ordering constraints such as cycles will lead to inconsistent behavior:
	 * some constraints will be respected and some will be ignored. If this happens, a warning will be logged.
	 *
	 * @param firstPhase The identifier of the phase that should run before the other. It will be created if it didn't exist yet.
	 * @param secondPhase The identifier of the phase that should run after the other. It will be created if it didn't exist yet.
	 */
	public void addPhaseOrdering(Identifier firstPhase, Identifier secondPhase) {
		// This is not abstract to avoid breaking existing Event subclasses, but they should really not be subclassing Event.
	}
}

Tooltip.class:

//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package net.minecraft.client.gui.tooltip;

import java.util.List;
import net.fabricmc.api.EnvType;
import net.fabricmc.api.Environment;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.gui.Narratable;
import net.minecraft.client.gui.screen.narration.NarrationMessageBuilder;
import net.minecraft.client.gui.screen.narration.NarrationPart;
import net.minecraft.text.OrderedText;
import net.minecraft.text.Text;
import net.minecraft.util.Language;
import org.jetbrains.annotations.Nullable;

@Environment(EnvType.CLIENT)
public class Tooltip implements Narratable {
    private static final int ROW_LENGTH = 170;
    private final Text content;
    @Nullable
    private List<OrderedText> lines;
    @Nullable
    private Language language;
    @Nullable
    private final Text narration;

    private Tooltip(Text content, @Nullable Text narration) {
        this.content = content;
        this.narration = narration;
    }

    public static Tooltip of(Text content, @Nullable Text narration) {
        return new Tooltip(content, narration);
    }

    public static Tooltip of(Text content) {
        return new Tooltip(content, content);
    }

    public void appendNarrations(NarrationMessageBuilder builder) {
        if (this.narration != null) {
            builder.put(NarrationPart.HINT, this.narration);
        }

    }

    public List<OrderedText> getLines(MinecraftClient client) {
        Language language = Language.getInstance();
        if (this.lines == null || language != this.language) {
            this.lines = wrapLines(client, this.content);
            this.language = language;
        }

        return this.lines;
    }

    public static List<OrderedText> wrapLines(MinecraftClient client, Text text) {
        return client.textRenderer.wrapLines(text, 170);
    }
}

ScreenEvents.java:

/*
 * Copyright (c) 2016, 2017, 2018, 2019 FabricMC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package net.fabricmc.fabric.api.client.screen.v1;

import java.util.Objects;
import net.fabricmc.fabric.api.event.Event;
import net.fabricmc.fabric.api.event.EventFactory;
import net.fabricmc.fabric.impl.client.screen.ScreenExtensions;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.gui.DrawContext;
import net.minecraft.client.gui.screen.Screen;

/**
 * Holds events related to {@link Screen}s.
 *
 * <p>Some events require a screen instance in order to obtain an event instance.
 * The events that require a screen instance can be identified by the use of a method passing a screen instance.
 * All events in {@link ScreenKeyboardEvents} and {@link ScreenMouseEvents} require a screen instance.
 * This registration model is used since a screen being (re)initialized will reset the screen to its default state, therefore reverting all changes a mod developer may have applied to a screen.
 * Furthermore, this design was chosen to reduce the amount of wasted iterations of events as a mod developer would only need to register screen events for rendering, ticking, keyboards and mice if needed on a per-instance basis.
 *
 * <p>The primary entrypoint into a screen is when it is being opened, this is signified by an event {@link ScreenEvents#BEFORE_INIT before} and {@link ScreenEvents#AFTER_INIT after} initialization of the screen.
 *
 * @see Screens
 * @see ScreenKeyboardEvents
 * @see ScreenMouseEvents
 */

public final class ScreenEvents {
	/**
	 * An event that is called before {@link Screen#init(MinecraftClient, int, int) a screen is initialized} to its default state.
	 * It should be noted some methods in {@link Screens} such as a screen's {@link Screen#getTextRenderer text renderer} may not be initialized yet, and as such their use is discouraged.
	 *
	 * <!--<p>Typically this event is used to register screen events such as listening to when child elements are added to the screen. ------ Uncomment when child add/remove event is added for elements-->
	 * You can still use {@link ScreenEvents#AFTER_INIT} to register events such as keyboard and mouse events.
	 *
	 * <p>The {@link ScreenExtensions} provided by the {@code info} parameter may be used to register tick, render events, keyboard, mouse, additional and removal of child elements (including buttons).
	 * For example, to register an event on inventory like screens after render, the following code could be used:
	 * <pre>{@code
	 * &#64;Override
	 * public void onInitializeClient() {
	 * 	ScreenEvents.BEFORE_INIT.register((client, screen, scaledWidth, scaledHeight) -> {
	 * 		if (screen instanceof AbstractInventoryScreen) {
	 * 			ScreenEvents.afterRender(screen).register((screen1, matrices, mouseX, mouseY, tickDelta) -> {
	 * 				...
	 * 			});
	 * 		}
	 * 	});
	 * }
	 * }</pre>
	 *
	 * <p>This event indicates a screen has been resized, and therefore is being re-initialized.
	 * This event can also indicate that the previous screen has been changed.
	 * @see ScreenEvents#AFTER_INIT
	 */
	public static final Event<BeforeInit> BEFORE_INIT = EventFactory.createArrayBacked(BeforeInit.class, callbacks -> (client, screen, scaledWidth, scaledHeight) -> {
		for (BeforeInit callback : callbacks) {
			callback.beforeInit(client, screen, scaledWidth, scaledHeight);
		}
	});

	/**
	 * An event that is called after {@link Screen#init(MinecraftClient, int, int) a screen is initialized} to its default state.
	 *
	 * <p>Typically this event is used to modify a screen after the screen has been initialized.
	 * Modifications such as changing sizes of buttons, removing buttons and adding/removing child elements to the screen can be done safely using this event.
	 *
	 * <p>For example, to add a button to the title screen, the following code could be used:
	 * <pre>{@code
	 * ScreenEvents.AFTER_INIT.register((client, screen, scaledWidth, scaledHeight) -> {
	 * 	if (screen instanceof TitleScreen) {
	 * 		Screens.getButtons(screen).add(new ButtonWidget(...));
	 * 	}
	 * });
	 * }</pre>
	 *
	 * <p>Note that by adding an element to a screen, the element is not automatically {@link net.minecraft.client.gui.Drawable drawn}.
	 * Unless the element is button, you need to call the specific {@link net.minecraft.client.gui.Drawable#render(DrawContext, int, int, float) render} methods in the corresponding screen events.
	 *
	 * <p>This event can also indicate that the previous screen has been closed.
	 * @see ScreenEvents#BEFORE_INIT
	 */
	public static final Event<AfterInit> AFTER_INIT = EventFactory.createArrayBacked(AfterInit.class, callbacks -> (client, screen, scaledWidth, scaledHeight) -> {
		for (AfterInit callback : callbacks) {
			callback.afterInit(client, screen, scaledWidth, scaledHeight);
		}
	});

	/**
	 * An event that is called after {@link Screen#removed()} is called.
	 * This event signifies that the screen is now closed.
	 *
	 * <p>This event is typically used to undo any screen specific state changes or to terminate threads spawned by a screen.
	 * This event may precede initialization events {@link ScreenEvents#BEFORE_INIT} but there is no guarantee that event will be called immediately afterwards.
	 */
	public static Event<Remove> remove(Screen screen) {
		Objects.requireNonNull(screen, "Screen cannot be null");

		return ScreenExtensions.getExtensions(screen).fabric_getRemoveEvent();
	}

	/**
	 * An event that is called before a screen is rendered.
	 *
	 * @return the event
	 */
	public static Event<BeforeRender> beforeRender(Screen screen) {
		Objects.requireNonNull(screen, "Screen cannot be null");

		return ScreenExtensions.getExtensions(screen).fabric_getBeforeRenderEvent();
	}

	/**
	 * An event that is called after a screen is rendered.
	 *
	 * @return the event
	 */
	public static Event<AfterRender> afterRender(Screen screen) {
		Objects.requireNonNull(screen, "Screen cannot be null");

		return ScreenExtensions.getExtensions(screen).fabric_getAfterRenderEvent();
	}

	/**
	 * An event that is called before a screen is ticked.
	 *
	 * @return the event
	 */
	public static Event<BeforeTick> beforeTick(Screen screen) {
		Objects.requireNonNull(screen, "Screen cannot be null");

		return ScreenExtensions.getExtensions(screen).fabric_getBeforeTickEvent();
	}

	/**
	 * An event that is called after a screen is ticked.
	 *
	 * @return the event
	 */
	public static Event<AfterTick> afterTick(Screen screen) {
		Objects.requireNonNull(screen, "Screen cannot be null");

		return ScreenExtensions.getExtensions(screen).fabric_getAfterTickEvent();
	}

	@FunctionalInterface
	public interface BeforeInit {
		void beforeInit(MinecraftClient client, Screen screen, int scaledWidth, int scaledHeight);
	}

	@FunctionalInterface
	public interface AfterInit {
		void afterInit(MinecraftClient client, Screen screen, int scaledWidth, int scaledHeight);
	}

	@FunctionalInterface
	public interface Remove {
		void onRemove(Screen screen);
	}

	@FunctionalInterface
	public interface BeforeRender {
		void beforeRender(Screen screen, DrawContext drawContext, int mouseX, int mouseY, float tickDelta);
	}

	@FunctionalInterface
	public interface AfterRender {
		void afterRender(Screen screen, DrawContext drawContext, int mouseX, int mouseY, float tickDelta);
	}

	@FunctionalInterface
	public interface BeforeTick {
		void beforeTick(Screen screen);
	}

	@FunctionalInterface
	public interface AfterTick {
		void afterTick(Screen screen);
	}

	private ScreenEvents() {
	}
}

ButtonWidget.class:

//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package net.minecraft.client.gui.widget;

import java.util.function.Supplier;
import net.fabricmc.api.EnvType;
import net.fabricmc.api.Environment;
import net.minecraft.client.gui.screen.narration.NarrationMessageBuilder;
import net.minecraft.client.gui.tooltip.Tooltip;
import net.minecraft.text.MutableText;
import net.minecraft.text.Text;
import org.jetbrains.annotations.Nullable;

@Environment(EnvType.CLIENT)
public class ButtonWidget extends PressableWidget {
    public static final int DEFAULT_WIDTH_SMALL = 120;
    public static final int DEFAULT_WIDTH = 150;
    public static final int field_49479 = 200;
    public static final int DEFAULT_HEIGHT = 20;
    public static final int field_46856 = 8;
    protected static final NarrationSupplier DEFAULT_NARRATION_SUPPLIER = (textSupplier) -> (MutableText)textSupplier.get();
    protected final PressAction onPress;
    protected final NarrationSupplier narrationSupplier;

    public static Builder builder(Text message, PressAction onPress) {
        return new Builder(message, onPress);
    }

    protected ButtonWidget(int x, int y, int width, int height, Text message, PressAction onPress, NarrationSupplier narrationSupplier) {
        super(x, y, width, height, message);
        this.onPress = onPress;
        this.narrationSupplier = narrationSupplier;
    }

    public void onPress() {
        this.onPress.onPress(this);
    }

    protected MutableText getNarrationMessage() {
        return this.narrationSupplier.createNarrationMessage(() -> super.getNarrationMessage());
    }

    public void appendClickableNarrations(NarrationMessageBuilder builder) {
        this.appendDefaultNarrations(builder);
    }

    @Environment(EnvType.CLIENT)
    public static class Builder {
        private final Text message;
        private final PressAction onPress;
        @Nullable
        private Tooltip tooltip;
        private int x;
        private int y;
        private int width = 150;
        private int height = 20;
        private NarrationSupplier narrationSupplier;

        public Builder(Text message, PressAction onPress) {
            this.narrationSupplier = ButtonWidget.DEFAULT_NARRATION_SUPPLIER;
            this.message = message;
            this.onPress = onPress;
        }

        public Builder position(int x, int y) {
            this.x = x;
            this.y = y;
            return this;
        }

        public Builder width(int width) {
            this.width = width;
            return this;
        }

        public Builder size(int width, int height) {
            this.width = width;
            this.height = height;
            return this;
        }

        public Builder dimensions(int x, int y, int width, int height) {
            return this.position(x, y).size(width, height);
        }

        public Builder tooltip(@Nullable Tooltip tooltip) {
            this.tooltip = tooltip;
            return this;
        }

        public Builder narrationSupplier(NarrationSupplier narrationSupplier) {
            this.narrationSupplier = narrationSupplier;
            return this;
        }

        public ButtonWidget build() {
            ButtonWidget buttonWidget = new ButtonWidget(this.x, this.y, this.width, this.height, this.message, this.onPress, this.narrationSupplier);
            buttonWidget.setTooltip(this.tooltip);
            return buttonWidget;
        }
    }

    @Environment(EnvType.CLIENT)
    public interface NarrationSupplier {
        MutableText createNarrationMessage(Supplier<MutableText> textSupplier);
    }

    @Environment(EnvType.CLIENT)
    public interface PressAction {
        void onPress(ButtonWidget button);
    }
}

GameMenuScreen.class:

//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package net.minecraft.client.gui.screen;

import java.net.URI;
import java.util.Objects;
import java.util.Optional;
import java.util.function.Supplier;
import net.fabricmc.api.EnvType;
import net.fabricmc.api.Environment;
import net.minecraft.SharedConstants;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.gl.RenderPipelines;
import net.minecraft.client.gui.DrawContext;
import net.minecraft.client.gui.screen.advancement.AdvancementsScreen;
import net.minecraft.client.gui.screen.multiplayer.MultiplayerScreen;
import net.minecraft.client.gui.screen.multiplayer.SocialInteractionsScreen;
import net.minecraft.client.gui.screen.option.OptionsScreen;
import net.minecraft.client.gui.tooltip.Tooltip;
import net.minecraft.client.gui.widget.ButtonWidget;
import net.minecraft.client.gui.widget.GridWidget;
import net.minecraft.client.gui.widget.SimplePositioningWidget;
import net.minecraft.client.gui.widget.TextWidget;
import net.minecraft.client.gui.widget.ThreePartsLayoutWidget;
import net.minecraft.client.network.ServerInfo;
import net.minecraft.client.option.GameOptions;
import net.minecraft.client.realms.gui.screen.RealmsMainScreen;
import net.minecraft.client.toast.NowPlayingToast;
import net.minecraft.client.world.ClientWorld;
import net.minecraft.dialog.Dialogs;
import net.minecraft.dialog.type.Dialog;
import net.minecraft.registry.Registry;
import net.minecraft.registry.RegistryKeys;
import net.minecraft.registry.entry.RegistryEntry;
import net.minecraft.registry.entry.RegistryEntryList;
import net.minecraft.registry.tag.DialogTags;
import net.minecraft.screen.ScreenTexts;
import net.minecraft.server.ServerLinks;
import net.minecraft.sound.SoundCategory;
import net.minecraft.text.Text;
import net.minecraft.util.Identifier;
import net.minecraft.util.Urls;
import org.jetbrains.annotations.Nullable;

@Environment(EnvType.CLIENT)
public class GameMenuScreen extends Screen {
    private static final Identifier DRAFT_REPORT_ICON_TEXTURE = Identifier.ofVanilla("icon/draft_report");
    private static final int GRID_COLUMNS = 2;
    private static final int BUTTONS_TOP_MARGIN = 50;
    private static final int GRID_MARGIN = 4;
    private static final int WIDE_BUTTON_WIDTH = 204;
    private static final int NORMAL_BUTTON_WIDTH = 98;
    private static final Text RETURN_TO_GAME_TEXT = Text.translatable("menu.returnToGame");
    private static final Text ADVANCEMENTS_TEXT = Text.translatable("gui.advancements");
    private static final Text STATS_TEXT = Text.translatable("gui.stats");
    private static final Text SEND_FEEDBACK_TEXT = Text.translatable("menu.sendFeedback");
    private static final Text REPORT_BUGS_TEXT = Text.translatable("menu.reportBugs");
    private static final Text FEEDBACK_TEXT = Text.translatable("menu.feedback");
    private static final Text OPTIONS_TEXT = Text.translatable("menu.options");
    private static final Text SHARE_TO_LAN_TEXT = Text.translatable("menu.shareToLan");
    private static final Text PLAYER_REPORTING_TEXT = Text.translatable("menu.playerReporting");
    private static final Text GAME_TEXT = Text.translatable("menu.game");
    private static final Text PAUSED_TEXT = Text.translatable("menu.paused");
    private static final Tooltip CUSTOM_OPTIONS_TOOLTIP = Tooltip.of(Text.translatable("menu.custom_options.tooltip"));
    private final boolean showMenu;
    @Nullable
    private ButtonWidget exitButton;

    public GameMenuScreen(boolean showMenu) {
        super(showMenu ? GAME_TEXT : PAUSED_TEXT);
        this.showMenu = showMenu;
    }

    public boolean shouldShowMenu() {
        return this.showMenu;
    }

    protected void init() {
        if (this.showMenu) {
            this.initWidgets();
        }

        int var10004 = this.showMenu ? 40 : 10;
        int var10005 = this.width;
        Objects.requireNonNull(this.textRenderer);
        this.addDrawableChild(new TextWidget(0, var10004, var10005, 9, this.title, this.textRenderer));
    }

    private void initWidgets() {
        GridWidget gridWidget = new GridWidget();
        gridWidget.getMainPositioner().margin(4, 4, 4, 0);
        GridWidget.Adder adder = gridWidget.createAdder(2);
        adder.add(ButtonWidget.builder(RETURN_TO_GAME_TEXT, (button) -> {
            this.client.setScreen((Screen)null);
            this.client.mouse.lockCursor();
        }).width(204).build(), 2, gridWidget.copyPositioner().marginTop(50));
        adder.add(this.createButton(ADVANCEMENTS_TEXT, () -> new AdvancementsScreen(this.client.player.networkHandler.getAdvancementHandler(), this)));
        adder.add(this.createButton(STATS_TEXT, () -> new StatsScreen(this, this.client.player.getStatHandler())));
        Optional<? extends RegistryEntry<Dialog>> optional = this.getCustomOptionsDialog();
        if (optional.isEmpty()) {
            addFeedbackAndBugsButtons(this, adder);
        } else {
            this.addFeedbackAndCustomOptionsButtons(this.client, (RegistryEntry)optional.get(), adder);
        }

        adder.add(this.createButton(OPTIONS_TEXT, () -> new OptionsScreen(this, this.client.options)));
        if (this.client.isIntegratedServerRunning() && !this.client.getServer().isRemote()) {
            adder.add(this.createButton(SHARE_TO_LAN_TEXT, () -> new OpenToLanScreen(this)));
        } else {
            adder.add(this.createButton(PLAYER_REPORTING_TEXT, () -> new SocialInteractionsScreen(this)));
        }

        this.exitButton = (ButtonWidget)adder.add(ButtonWidget.builder(ScreenTexts.returnToMenuOrDisconnect(this.client.isInSingleplayer()), (button) -> {
            button.active = false;
            this.client.getAbuseReportContext().tryShowDraftScreen(this.client, this, () -> disconnect(this.client, ClientWorld.QUITTING_MULTIPLAYER_TEXT), true);
        }).width(204).build(), 2);
        gridWidget.refreshPositions();
        SimplePositioningWidget.setPos(gridWidget, 0, 0, this.width, this.height, 0.5F, 0.25F);
        gridWidget.forEachChild(this::addDrawableChild);
    }

    private Optional<? extends RegistryEntry<Dialog>> getCustomOptionsDialog() {
        Registry<Dialog> registry = this.client.player.networkHandler.getRegistryManager().getOrThrow(RegistryKeys.DIALOG);
        Optional<? extends RegistryEntryList<Dialog>> optional = registry.getOptional(DialogTags.PAUSE_SCREEN_ADDITIONS);
        if (optional.isPresent()) {
            RegistryEntryList<Dialog> registryEntryList = (RegistryEntryList)optional.get();
            if (registryEntryList.size() > 0) {
                if (registryEntryList.size() == 1) {
                    return Optional.of(registryEntryList.get(0));
                }

                return registry.getOptional(Dialogs.CUSTOM_OPTIONS);
            }
        }

        ServerLinks serverLinks = this.client.player.networkHandler.getServerLinks();
        return !serverLinks.isEmpty() ? registry.getOptional(Dialogs.SERVER_LINKS) : Optional.empty();
    }

    static void addFeedbackAndBugsButtons(Screen parentScreen, GridWidget.Adder gridAdder) {
        gridAdder.add(createUrlButton(parentScreen, SEND_FEEDBACK_TEXT, SharedConstants.getGameVersion().stable() ? Urls.JAVA_FEEDBACK : Urls.SNAPSHOT_FEEDBACK));
        ((ButtonWidget)gridAdder.add(createUrlButton(parentScreen, REPORT_BUGS_TEXT, Urls.SNAPSHOT_BUGS))).active = !SharedConstants.getGameVersion().dataVersion().isNotMainSeries();
    }

    private void addFeedbackAndCustomOptionsButtons(MinecraftClient client, RegistryEntry<Dialog> dialog, GridWidget.Adder gridAdder) {
        gridAdder.add(this.createButton(FEEDBACK_TEXT, () -> new FeedbackScreen(this)));
        gridAdder.add(ButtonWidget.builder(((Dialog)dialog.value()).common().getExternalTitle(), (button) -> client.player.networkHandler.showDialog(dialog, this)).width(98).tooltip(CUSTOM_OPTIONS_TOOLTIP).build());
    }

    public static void disconnect(MinecraftClient client, Text disconnectReason) {
        boolean bl = client.isInSingleplayer();
        ServerInfo serverInfo = client.getCurrentServerEntry();
        if (client.world != null) {
            client.world.disconnect(disconnectReason);
        }

        if (bl) {
            client.disconnectWithSavingScreen();
        } else {
            client.disconnectWithProgressScreen();
        }

        TitleScreen titleScreen = new TitleScreen();
        if (bl) {
            client.setScreen(titleScreen);
        } else if (serverInfo != null && serverInfo.isRealm()) {
            client.setScreen(new RealmsMainScreen(titleScreen));
        } else {
            client.setScreen(new MultiplayerScreen(titleScreen));
        }

    }

    public void tick() {
        if (this.shouldShowNowPlayingToast()) {
            NowPlayingToast.tick();
        }

    }

    public void render(DrawContext context, int mouseX, int mouseY, float deltaTicks) {
        super.render(context, mouseX, mouseY, deltaTicks);
        if (this.shouldShowNowPlayingToast()) {
            NowPlayingToast.draw(context, this.textRenderer);
        }

        if (this.showMenu && this.client != null && this.client.getAbuseReportContext().hasDraft() && this.exitButton != null) {
            context.drawGuiTexture(RenderPipelines.GUI_TEXTURED, DRAFT_REPORT_ICON_TEXTURE, this.exitButton.getX() + this.exitButton.getWidth() - 17, this.exitButton.getY() + 3, 15, 15);
        }

    }

    public void renderBackground(DrawContext context, int mouseX, int mouseY, float deltaTicks) {
        if (this.showMenu) {
            super.renderBackground(context, mouseX, mouseY, deltaTicks);
        }

    }

    public boolean shouldShowNowPlayingToast() {
        GameOptions gameOptions = this.client.options;
        return (Boolean)gameOptions.getShowNowPlayingToast().getValue() && gameOptions.getSoundVolume(SoundCategory.MUSIC) > 0.0F && this.showMenu;
    }

    private ButtonWidget createButton(Text text, Supplier<Screen> screenSupplier) {
        return ButtonWidget.builder(text, (button) -> this.client.setScreen((Screen)screenSupplier.get())).width(98).build();
    }

    private static ButtonWidget createUrlButton(Screen parent, Text text, URI uri) {
        return ButtonWidget.builder(text, ConfirmLinkScreen.opening(parent, uri)).width(98).build();
    }

    @Environment(EnvType.CLIENT)
    static class FeedbackScreen extends Screen {
        private static final Text TITLE = Text.translatable("menu.feedback.title");
        public final Screen parent;
        private final ThreePartsLayoutWidget layoutWidget = new ThreePartsLayoutWidget(this);

        protected FeedbackScreen(Screen parent) {
            super(TITLE);
            this.parent = parent;
        }

        protected void init() {
            this.layoutWidget.addHeader(TITLE, this.textRenderer);
            GridWidget gridWidget = (GridWidget)this.layoutWidget.addBody(new GridWidget());
            gridWidget.getMainPositioner().margin(4, 4, 4, 0);
            GridWidget.Adder adder = gridWidget.createAdder(2);
            GameMenuScreen.addFeedbackAndBugsButtons(this, adder);
            this.layoutWidget.addFooter(ButtonWidget.builder(ScreenTexts.BACK, (button) -> this.close()).width(200).build());
            this.layoutWidget.forEachChild(this::addDrawableChild);
            this.refreshWidgetPositions();
        }

        protected void refreshWidgetPositions() {
            this.layoutWidget.refreshPositions();
        }

        public void close() {
            this.client.setScreen(this.parent);
        }
    }
}

Screen.class:

//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package net.minecraft.client.gui.screen;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.Lists;
import com.mojang.logging.LogUtils;
import java.net.URI;
import java.nio.file.Path;
import java.util.Comparator;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;
import net.fabricmc.api.EnvType;
import net.fabricmc.api.Environment;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.font.TextRenderer;
import net.minecraft.client.gl.RenderPipelines;
import net.minecraft.client.gui.AbstractParentElement;
import net.minecraft.client.gui.DrawContext;
import net.minecraft.client.gui.Drawable;
import net.minecraft.client.gui.Element;
import net.minecraft.client.gui.ScreenRect;
import net.minecraft.client.gui.Selectable;
import net.minecraft.client.gui.Selectable.SelectionType;
import net.minecraft.client.gui.navigation.GuiNavigation;
import net.minecraft.client.gui.navigation.GuiNavigationPath;
import net.minecraft.client.gui.navigation.Navigable;
import net.minecraft.client.gui.navigation.NavigationDirection;
import net.minecraft.client.gui.screen.narration.NarrationMessageBuilder;
import net.minecraft.client.gui.screen.narration.NarrationPart;
import net.minecraft.client.gui.screen.narration.ScreenNarrator;
import net.minecraft.client.gui.widget.ClickableWidget;
import net.minecraft.client.gui.widget.CyclingButtonWidget;
import net.minecraft.client.network.ClientPlayerEntity;
import net.minecraft.client.option.NarratorMode;
import net.minecraft.client.util.InputUtil;
import net.minecraft.item.ItemStack;
import net.minecraft.item.Item.TooltipContext;
import net.minecraft.item.tooltip.TooltipType.Default;
import net.minecraft.network.packet.c2s.common.CustomClickActionC2SPacket;
import net.minecraft.server.command.CommandManager;
import net.minecraft.sound.MusicSound;
import net.minecraft.text.ClickEvent;
import net.minecraft.text.Style;
import net.minecraft.text.Text;
import net.minecraft.util.Identifier;
import net.minecraft.util.Util;
import net.minecraft.util.crash.CrashReport;
import net.minecraft.util.crash.CrashReportSection;
import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;

@Environment(EnvType.CLIENT)
public abstract class Screen extends AbstractParentElement implements Drawable {
    private static final Logger LOGGER = LogUtils.getLogger();
    private static final Text SCREEN_USAGE_TEXT = Text.translatable("narrator.screen.usage");
    public static final Identifier MENU_BACKGROUND_TEXTURE = Identifier.ofVanilla("textures/gui/menu_background.png");
    public static final Identifier HEADER_SEPARATOR_TEXTURE = Identifier.ofVanilla("textures/gui/header_separator.png");
    public static final Identifier FOOTER_SEPARATOR_TEXTURE = Identifier.ofVanilla("textures/gui/footer_separator.png");
    private static final Identifier INWORLD_MENU_BACKGROUND_TEXTURE = Identifier.ofVanilla("textures/gui/inworld_menu_background.png");
    public static final Identifier INWORLD_HEADER_SEPARATOR_TEXTURE = Identifier.ofVanilla("textures/gui/inworld_header_separator.png");
    public static final Identifier INWORLD_FOOTER_SEPARATOR_TEXTURE = Identifier.ofVanilla("textures/gui/inworld_footer_separator.png");
    protected static final float field_60460 = 2000.0F;
    protected final Text title;
    private final List<Element> children = Lists.newArrayList();
    private final List<Selectable> selectables = Lists.newArrayList();
    @Nullable
    protected MinecraftClient client;
    private boolean screenInitialized;
    public int width;
    public int height;
    private final List<Drawable> drawables = Lists.newArrayList();
    protected TextRenderer textRenderer;
    private static final long SCREEN_INIT_NARRATION_DELAY;
    private static final long NARRATOR_MODE_CHANGE_DELAY;
    private static final long MOUSE_MOVE_NARRATION_DELAY = 750L;
    private static final long MOUSE_PRESS_SCROLL_NARRATION_DELAY = 200L;
    private static final long KEY_PRESS_NARRATION_DELAY = 200L;
    private final ScreenNarrator narrator = new ScreenNarrator();
    private long elementNarrationStartTime = Long.MIN_VALUE;
    private long screenNarrationStartTime = Long.MAX_VALUE;
    @Nullable
    protected CyclingButtonWidget<NarratorMode> narratorToggleButton;
    @Nullable
    private Selectable selected;
    protected final Executor executor = (runnable) -> this.client.execute(() -> {
            if (this.client.currentScreen == this) {
                runnable.run();
            }

        });

    protected Screen(Text title) {
        this.title = title;
    }

    public Text getTitle() {
        return this.title;
    }

    public Text getNarratedTitle() {
        return this.getTitle();
    }

    public final void renderWithTooltip(DrawContext context, int mouseX, int mouseY, float deltaTicks) {
        context.createNewRootLayer();
        this.renderBackground(context, mouseX, mouseY, deltaTicks);
        context.createNewRootLayer();
        this.render(context, mouseX, mouseY, deltaTicks);
        context.renderTooltip();
    }

    public void render(DrawContext context, int mouseX, int mouseY, float deltaTicks) {
        for(Drawable drawable : this.drawables) {
            drawable.render(context, mouseX, mouseY, deltaTicks);
        }

    }

    public boolean keyPressed(int keyCode, int scanCode, int modifiers) {
        if (keyCode == 256 && this.shouldCloseOnEsc()) {
            this.close();
            return true;
        } else if (super.keyPressed(keyCode, scanCode, modifiers)) {
            return true;
        } else {
            Object var10000;
            switch (keyCode) {
                case 258:
                    var10000 = this.getTabNavigation();
                    break;
                case 259:
                case 260:
                case 261:
                default:
                    var10000 = null;
                    break;
                case 262:
                    var10000 = this.getArrowNavigation(NavigationDirection.RIGHT);
                    break;
                case 263:
                    var10000 = this.getArrowNavigation(NavigationDirection.LEFT);
                    break;
                case 264:
                    var10000 = this.getArrowNavigation(NavigationDirection.DOWN);
                    break;
                case 265:
                    var10000 = this.getArrowNavigation(NavigationDirection.UP);
            }

            GuiNavigation guiNavigation = (GuiNavigation)var10000;
            if (guiNavigation != null) {
                GuiNavigationPath guiNavigationPath = super.getNavigationPath(guiNavigation);
                if (guiNavigationPath == null && guiNavigation instanceof GuiNavigation.Tab) {
                    this.blur();
                    guiNavigationPath = super.getNavigationPath(guiNavigation);
                }

                if (guiNavigationPath != null) {
                    this.switchFocus(guiNavigationPath);
                }
            }

            return false;
        }
    }

    private GuiNavigation.Tab getTabNavigation() {
        boolean bl = !hasShiftDown();
        return new GuiNavigation.Tab(bl);
    }

    private GuiNavigation.Arrow getArrowNavigation(NavigationDirection direction) {
        return new GuiNavigation.Arrow(direction);
    }

    protected void setInitialFocus() {
        if (this.client.getNavigationType().isKeyboard()) {
            GuiNavigation.Tab tab = new GuiNavigation.Tab(true);
            GuiNavigationPath guiNavigationPath = super.getNavigationPath(tab);
            if (guiNavigationPath != null) {
                this.switchFocus(guiNavigationPath);
            }
        }

    }

    protected void setInitialFocus(Element element) {
        GuiNavigationPath guiNavigationPath = GuiNavigationPath.of(this, element.getNavigationPath(new GuiNavigation.Down()));
        if (guiNavigationPath != null) {
            this.switchFocus(guiNavigationPath);
        }

    }

    public void blur() {
        GuiNavigationPath guiNavigationPath = this.getFocusedPath();
        if (guiNavigationPath != null) {
            guiNavigationPath.setFocused(false);
        }

    }

    @VisibleForTesting
    protected void switchFocus(GuiNavigationPath path) {
        this.blur();
        path.setFocused(true);
    }

    public boolean shouldCloseOnEsc() {
        return true;
    }

    public void close() {
        this.client.setScreen((Screen)null);
    }

    protected <T extends Element & Drawable & Selectable> T addDrawableChild(T drawableElement) {
        this.drawables.add(drawableElement);
        return (T)this.addSelectableChild(drawableElement);
    }

    protected <T extends Drawable> T addDrawable(T drawable) {
        this.drawables.add(drawable);
        return drawable;
    }

    protected <T extends Element & Selectable> T addSelectableChild(T child) {
        this.children.add(child);
        this.selectables.add(child);
        return child;
    }

    protected void remove(Element child) {
        if (child instanceof Drawable) {
            this.drawables.remove((Drawable)child);
        }

        if (child instanceof Selectable) {
            this.selectables.remove((Selectable)child);
        }

        this.children.remove(child);
    }

    protected void clearChildren() {
        this.drawables.clear();
        this.children.clear();
        this.selectables.clear();
    }

    public static List<Text> getTooltipFromItem(MinecraftClient client, ItemStack stack) {
        return stack.getTooltip(TooltipContext.create(client.world), client.player, client.options.advancedItemTooltips ? Default.ADVANCED : Default.BASIC);
    }

    protected void insertText(String text, boolean override) {
    }

    public boolean handleTextClick(Style style) {
        ClickEvent clickEvent = style.getClickEvent();
        if (hasShiftDown()) {
            if (style.getInsertion() != null) {
                this.insertText(style.getInsertion(), false);
            }
        } else if (clickEvent != null) {
            this.handleClickEvent(this.client, clickEvent);
            return true;
        }

        return false;
    }

    protected void handleClickEvent(MinecraftClient client, ClickEvent clickEvent) {
        handleClickEvent(clickEvent, client, this);
    }

    protected static void handleClickEvent(ClickEvent clickEvent, MinecraftClient client, @Nullable Screen screenAfterRun) {
        ClientPlayerEntity clientPlayerEntity = (ClientPlayerEntity)Objects.requireNonNull(client.player, "Player not available");
        switch (clickEvent) {
            case ClickEvent.RunCommand(String string):
                handleRunCommand(clientPlayerEntity, string, screenAfterRun);
                break;
            case ClickEvent.ShowDialog showDialog:
                clientPlayerEntity.networkHandler.showDialog(showDialog.dialog(), screenAfterRun);
                break;
            case ClickEvent.Custom custom:
                clientPlayerEntity.networkHandler.sendPacket(new CustomClickActionC2SPacket(custom.id(), custom.payload()));
                if (client.currentScreen != screenAfterRun) {
                    client.setScreen(screenAfterRun);
                }
                break;
            default:
                handleBasicClickEvent(clickEvent, client, screenAfterRun);
        }

    }

    protected static void handleBasicClickEvent(ClickEvent clickEvent, MinecraftClient client, @Nullable Screen screenAfterRun) {
        boolean var20;
        switch (clickEvent) {
            case ClickEvent.OpenUrl(URI uRI):
                handleOpenUri(client, screenAfterRun, uRI);
                var20 = false;
                break;
            case ClickEvent.OpenFile openFile:
                Util.getOperatingSystem().open(openFile.file());
                var20 = true;
                break;
            case ClickEvent.SuggestCommand(String string):
                if (screenAfterRun != null) {
                    screenAfterRun.insertText(string, true);
                }

                var20 = true;
                break;
            case ClickEvent.CopyToClipboard(String string2):
                client.keyboard.setClipboard(string2);
                var20 = true;
                break;
            default:
                LOGGER.error("Don't know how to handle {}", clickEvent);
                var20 = true;
        }

        boolean bl = var20;
        if (bl && client.currentScreen != screenAfterRun) {
            client.setScreen(screenAfterRun);
        }

    }

    protected static boolean handleOpenUri(MinecraftClient client, @Nullable Screen screen, URI uri) {
        if (!(Boolean)client.options.getChatLinks().getValue()) {
            return false;
        } else {
            if ((Boolean)client.options.getChatLinksPrompt().getValue()) {
                client.setScreen(new ConfirmLinkScreen((confirmed) -> {
                    if (confirmed) {
                        Util.getOperatingSystem().open(uri);
                    }

                    client.setScreen(screen);
                }, uri.toString(), false));
            } else {
                Util.getOperatingSystem().open(uri);
            }

            return true;
        }
    }

    protected static void handleRunCommand(ClientPlayerEntity player, String command, @Nullable Screen screenAfterRun) {
        player.networkHandler.runClickEventCommand(CommandManager.stripLeadingSlash(command), screenAfterRun);
    }

    public final void init(MinecraftClient client, int width, int height) {
        this.client = client;
        this.textRenderer = client.textRenderer;
        this.width = width;
        this.height = height;
        if (!this.screenInitialized) {
            this.init();
            this.setInitialFocus();
        } else {
            this.refreshWidgetPositions();
        }

        this.screenInitialized = true;
        this.narrateScreenIfNarrationEnabled(false);
        this.setElementNarrationDelay(SCREEN_INIT_NARRATION_DELAY);
    }

    protected void clearAndInit() {
        this.clearChildren();
        this.blur();
        this.init();
        this.setInitialFocus();
    }

    protected void setWidgetAlpha(float alpha) {
        for(Element element : this.children()) {
            if (element instanceof ClickableWidget clickableWidget) {
                clickableWidget.setAlpha(alpha);
            }
        }

    }

    public List<? extends Element> children() {
        return this.children;
    }

    protected void init() {
    }

    public void tick() {
    }

    public void removed() {
    }

    public void onDisplayed() {
    }

    public void renderBackground(DrawContext context, int mouseX, int mouseY, float deltaTicks) {
        if (this.client.world == null) {
            this.renderPanoramaBackground(context, deltaTicks);
        }

        this.applyBlur(context);
        this.renderDarkening(context);
    }

    protected void applyBlur(DrawContext context) {
        float f = (float)this.client.options.getMenuBackgroundBlurrinessValue();
        if (f >= 1.0F) {
            context.applyBlur();
        }

    }

    protected void renderPanoramaBackground(DrawContext context, float deltaTicks) {
        this.client.gameRenderer.getRotatingPanoramaRenderer().render(context, this.width, this.height, true);
    }

    protected void renderDarkening(DrawContext context) {
        this.renderDarkening(context, 0, 0, this.width, this.height);
    }

    protected void renderDarkening(DrawContext context, int x, int y, int width, int height) {
        renderBackgroundTexture(context, this.client.world == null ? MENU_BACKGROUND_TEXTURE : INWORLD_MENU_BACKGROUND_TEXTURE, x, y, 0.0F, 0.0F, width, height);
    }

    public static void renderBackgroundTexture(DrawContext context, Identifier texture, int x, int y, float u, float v, int width, int height) {
        int i = 32;
        context.drawTexture(RenderPipelines.GUI_TEXTURED, texture, x, y, u, v, width, height, 32, 32);
    }

    public void renderInGameBackground(DrawContext context) {
        context.fillGradient(0, 0, this.width, this.height, -1072689136, -804253680);
    }

    public boolean shouldPause() {
        return true;
    }

    public static boolean hasControlDown() {
        if (MinecraftClient.IS_SYSTEM_MAC) {
            return InputUtil.isKeyPressed(MinecraftClient.getInstance().getWindow().getHandle(), 343) || InputUtil.isKeyPressed(MinecraftClient.getInstance().getWindow().getHandle(), 347);
        } else {
            return InputUtil.isKeyPressed(MinecraftClient.getInstance().getWindow().getHandle(), 341) || InputUtil.isKeyPressed(MinecraftClient.getInstance().getWindow().getHandle(), 345);
        }
    }

    public static boolean hasShiftDown() {
        return InputUtil.isKeyPressed(MinecraftClient.getInstance().getWindow().getHandle(), 340) || InputUtil.isKeyPressed(MinecraftClient.getInstance().getWindow().getHandle(), 344);
    }

    public static boolean hasAltDown() {
        return InputUtil.isKeyPressed(MinecraftClient.getInstance().getWindow().getHandle(), 342) || InputUtil.isKeyPressed(MinecraftClient.getInstance().getWindow().getHandle(), 346);
    }

    public static boolean isCut(int code) {
        return code == 88 && hasControlDown() && !hasShiftDown() && !hasAltDown();
    }

    public static boolean isPaste(int code) {
        return code == 86 && hasControlDown() && !hasShiftDown() && !hasAltDown();
    }

    public static boolean isCopy(int code) {
        return code == 67 && hasControlDown() && !hasShiftDown() && !hasAltDown();
    }

    public static boolean isSelectAll(int code) {
        return code == 65 && hasControlDown() && !hasShiftDown() && !hasAltDown();
    }

    protected void refreshWidgetPositions() {
        this.clearAndInit();
    }

    public void resize(MinecraftClient client, int width, int height) {
        this.width = width;
        this.height = height;
        this.refreshWidgetPositions();
    }

    public void addCrashReportSection(CrashReport report) {
        CrashReportSection crashReportSection = report.addElement("Affected screen", 1);
        crashReportSection.add("Screen name", () -> this.getClass().getCanonicalName());
    }

    protected boolean isValidCharacterForName(String name, char character, int cursorPos) {
        int i = name.indexOf(58);
        int j = name.indexOf(47);
        if (character == ':') {
            return (j == -1 || cursorPos <= j) && i == -1;
        } else if (character == '/') {
            return cursorPos > i;
        } else {
            return character == '_' || character == '-' || character >= 'a' && character <= 'z' || character >= '0' && character <= '9' || character == '.';
        }
    }

    public boolean isMouseOver(double mouseX, double mouseY) {
        return true;
    }

    public void onFilesDropped(List<Path> paths) {
    }

    private void setScreenNarrationDelay(long delayMs, boolean restartElementNarration) {
        this.screenNarrationStartTime = Util.getMeasuringTimeMs() + delayMs;
        if (restartElementNarration) {
            this.elementNarrationStartTime = Long.MIN_VALUE;
        }

    }

    private void setElementNarrationDelay(long delayMs) {
        this.elementNarrationStartTime = Util.getMeasuringTimeMs() + delayMs;
    }

    public void applyMouseMoveNarratorDelay() {
        this.setScreenNarrationDelay(750L, false);
    }

    public void applyMousePressScrollNarratorDelay() {
        this.setScreenNarrationDelay(200L, true);
    }

    public void applyKeyPressNarratorDelay() {
        this.setScreenNarrationDelay(200L, true);
    }

    private boolean isNarratorActive() {
        return this.client.getNarratorManager().isActive();
    }

    public void updateNarrator() {
        if (this.isNarratorActive()) {
            long l = Util.getMeasuringTimeMs();
            if (l > this.screenNarrationStartTime && l > this.elementNarrationStartTime) {
                this.narrateScreen(true);
                this.screenNarrationStartTime = Long.MAX_VALUE;
            }
        }

    }

    public void narrateScreenIfNarrationEnabled(boolean onlyChangedNarrations) {
        if (this.isNarratorActive()) {
            this.narrateScreen(onlyChangedNarrations);
        }

    }

    private void narrateScreen(boolean onlyChangedNarrations) {
        this.narrator.buildNarrations(this::addScreenNarrations);
        String string = this.narrator.buildNarratorText(!onlyChangedNarrations);
        if (!string.isEmpty()) {
            this.client.getNarratorManager().narrateSystemImmediately(string);
        }

    }

    protected boolean hasUsageText() {
        return true;
    }

    protected void addScreenNarrations(NarrationMessageBuilder messageBuilder) {
        messageBuilder.put(NarrationPart.TITLE, this.getNarratedTitle());
        if (this.hasUsageText()) {
            messageBuilder.put(NarrationPart.USAGE, SCREEN_USAGE_TEXT);
        }

        this.addElementNarrations(messageBuilder);
    }

    protected void addElementNarrations(NarrationMessageBuilder builder) {
        List<? extends Selectable> list = this.selectables.stream().flatMap((selectable) -> selectable.getNarratedParts().stream()).filter(Selectable::isNarratable).sorted(Comparator.comparingInt(Navigable::getNavigationOrder)).toList();
        SelectedElementNarrationData selectedElementNarrationData = findSelectedElementData(list, this.selected);
        if (selectedElementNarrationData != null) {
            if (selectedElementNarrationData.selectType.isFocused()) {
                this.selected = selectedElementNarrationData.selectable;
            }

            if (list.size() > 1) {
                builder.put(NarrationPart.POSITION, Text.translatable("narrator.position.screen", new Object[]{selectedElementNarrationData.index + 1, list.size()}));
                if (selectedElementNarrationData.selectType == SelectionType.FOCUSED) {
                    builder.put(NarrationPart.USAGE, this.getUsageNarrationText());
                }
            }

            selectedElementNarrationData.selectable.appendNarrations(builder.nextMessage());
        }

    }

    protected Text getUsageNarrationText() {
        return Text.translatable("narration.component_list.usage");
    }

    @Nullable
    public static SelectedElementNarrationData findSelectedElementData(List<? extends Selectable> selectables, @Nullable Selectable selectable) {
        SelectedElementNarrationData selectedElementNarrationData = null;
        SelectedElementNarrationData selectedElementNarrationData2 = null;
        int i = 0;

        for(int j = selectables.size(); i < j; ++i) {
            Selectable selectable2 = (Selectable)selectables.get(i);
            Selectable.SelectionType selectionType = selectable2.getType();
            if (selectionType.isFocused()) {
                if (selectable2 != selectable) {
                    return new SelectedElementNarrationData(selectable2, i, selectionType);
                }

                selectedElementNarrationData2 = new SelectedElementNarrationData(selectable2, i, selectionType);
            } else if (selectionType.compareTo(selectedElementNarrationData != null ? selectedElementNarrationData.selectType : SelectionType.NONE) > 0) {
                selectedElementNarrationData = new SelectedElementNarrationData(selectable2, i, selectionType);
            }
        }

        return selectedElementNarrationData != null ? selectedElementNarrationData : selectedElementNarrationData2;
    }

    public void refreshNarrator(boolean previouslyDisabled) {
        if (previouslyDisabled) {
            this.setScreenNarrationDelay(NARRATOR_MODE_CHANGE_DELAY, false);
        }

        if (this.narratorToggleButton != null) {
            this.narratorToggleButton.setValue((NarratorMode)this.client.options.getNarrator().getValue());
        }

    }

    public TextRenderer getTextRenderer() {
        return this.textRenderer;
    }

    public boolean showsStatusEffects() {
        return false;
    }

    public ScreenRect getNavigationFocus() {
        return new ScreenRect(0, 0, this.width, this.height);
    }

    @Nullable
    public MusicSound getMusic() {
        return null;
    }

    static {
        SCREEN_INIT_NARRATION_DELAY = TimeUnit.SECONDS.toMillis(2L);
        NARRATOR_MODE_CHANGE_DELAY = SCREEN_INIT_NARRATION_DELAY;
    }

    @Environment(EnvType.CLIENT)
    public static class SelectedElementNarrationData {
        public final Selectable selectable;
        public final int index;
        public final Selectable.SelectionType selectType;

        public SelectedElementNarrationData(Selectable selectable, int index, Selectable.SelectionType selectType) {
            this.selectable = selectable;
            this.index = index;
            this.selectType = selectType;
        }
    }
}