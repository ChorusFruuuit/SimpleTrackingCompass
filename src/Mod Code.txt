package me.chorus.playerfinderhud.client;

import me.chorus.playerfinderhud.CompassHUD;
import net.fabricmc.api.ClientModInitializer;

public class PlayerFinderHUDClient implements ClientModInitializer {

    @Override
    public void onInitializeClient() {
        CompassHUD.register();
        GameMenuCompassButton.register();
    }
}



package me.chorus.playerfinderhud.compat;

import com.terraformersmc.modmenu.api.ConfigScreenFactory;
import com.terraformersmc.modmenu.api.ModMenuApi;
import me.chorus.playerfinderhud.ModSettingsScreen;
import net.minecraft.client.MinecraftClient;

public class ModMenuIntegration implements ModMenuApi {
    @Override
    public ConfigScreenFactory<?> getModConfigScreenFactory() {
        return parent -> {
            MinecraftClient client = MinecraftClient.getInstance();
            if (client.world == null || client.player == null) {
                // Not in-game
                return null;
            }
            return new ModSettingsScreen(parent);
        };
    }
}



package me.chorus.playerfinderhud.mixin;

import net.minecraft.client.gui.Drawable;
import net.minecraft.client.gui.Element;
import net.minecraft.client.gui.Selectable;
import net.minecraft.client.gui.screen.Screen;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.gen.Invoker;

@Mixin(Screen.class)
public interface ScreenInvoker {
    @Invoker("addDrawableChild")
    <T extends Element & Drawable & Selectable> T invokeAddDrawableChild(T widget);
}



package me.chorus.playerfinderhud.util;

import net.minecraft.client.MinecraftClient;
import net.minecraft.client.gui.Element;
import net.minecraft.client.gui.screen.Screen;
import net.minecraft.client.gui.widget.ButtonWidget;
import net.minecraft.resource.Resource;
import net.minecraft.resource.ResourceManager;
import net.minecraft.text.TextContent;
import net.minecraft.text.TranslatableTextContent;
import net.minecraft.util.Identifier;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.Optional;

public class ModUtils {

    public static int[] getTextureSize(Identifier id) {
        ResourceManager rm = MinecraftClient.getInstance().getResourceManager();
        try {
            Optional<Resource> resource = rm.getResource(id);
            if (resource.isPresent()) {
                BufferedImage img = ImageIO.read(resource.get().getInputStream());
                return new int[]{img.getWidth(), img.getHeight()};
            } else {
                System.err.println("Texture not found: " + id);
            }
        } catch (IOException e) {
            System.err.println("Failed to load texture: " + id);
        }
        return new int[]{0, 0}; // default fallback
    }

    public static int[] scaleTextureToFit(Identifier id, int maxSide) {
        int[] size = getTextureSize(id);
        double scaleFactor = Math.max(size[0], size[1]) / (double) maxSide;
        int newWidth = (int) Math.round(size[0] / scaleFactor);
        int newHeight = (int) Math.round(size[1] / scaleFactor);

        return new int[]{newWidth, newHeight};
    }

    public static int[] getButtonPosition(Screen screen, String btnText) {
        int[] buttonPos = new int[]{0, 0, 0, 0};

        for (Element element : screen.children()) {
            if (element instanceof ButtonWidget button) {
                TextContent content = button.getMessage().getContent();
                if (content instanceof TranslatableTextContent tt &&
                        tt.getKey().equals(btnText)) {
                    buttonPos = new int[]{button.getX(), button.getY(),
                                          button.getWidth(), button.getHeight()};
                    break;
                }
            }
        }

        return buttonPos;
    }

    public static int calculateAngle(double playerX, double playerZ,
                                     double targetX, double targetZ) {
        double dx = targetX - playerX;
        double dz = targetZ - playerZ;

        double angleRad = Math.atan2(dz, dx);
        double angleDeg = Math.toDegrees(angleRad);
        return (int) ((angleDeg - 90 + 360) % 360);
    }
}



package me.chorus.playerfinderhud.util;

import net.minecraft.client.MinecraftClient;
import net.minecraft.client.network.PlayerListEntry;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.text.Text;
import net.minecraft.util.Formatting;

import java.util.UUID;

public class PlayerUtils {
    public static void invalidPlayerMessage(String playerName) {
        MinecraftClient client = MinecraftClient.getInstance();
        if (client == null || client.player == null) return;

        Text message = Text.literal(
                        "Cannot find " + playerName + ". Target player was set to:\n"
                ).formatted(Formatting.RED)
                .append(Text.literal(client.player.getName().getString()).formatted(Formatting.YELLOW));
        client.player.sendMessage(message, false);
    }

    public static void playerOutOfRenderDistanceMessage(String playerName) {
        MinecraftClient client = MinecraftClient.getInstance();
        if (client == null || client.player == null) return;

        Text message = Text.literal(
                playerName + " is not within your render distance."
        );
        client.player.sendMessage(message, false);
    }

    // returns null if the player is not on the server
    public static Boolean isWithinRenderDistance(UUID uuid) {
        MinecraftClient client = MinecraftClient.getInstance();
        if (uuid == null || client == null || client.world == null) return null;

        boolean listedInTab = false;
        for (PlayerListEntry p : client.getNetworkHandler().getPlayerList()) {
            if (p.getProfile().getId().equals(uuid)) {
                listedInTab = true;
                break;
            }
        }

        boolean withinRenderDistance = false;
        for (PlayerEntity p : client.world.getPlayers()) {
            if (p.getUuid().equals(uuid)) {
                withinRenderDistance = true;
                break;
            }
        }

        return listedInTab ? withinRenderDistance : null;
    }

    public static PlayerEntity getPlayerEntity(UUID uuid) {
        MinecraftClient client = MinecraftClient.getInstance();
        if (client == null || client.world == null) return null;

        PlayerEntity player = null;
        for (PlayerEntity p : client.world.getPlayers()) {
            if (uuid.equals(p.getUuid())) {
                player = p;
                break;
            }
        }

        return player;
    }
}



package me.chorus.playerfinderhud.util;

import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.registry.RegistryKey;
import net.minecraft.world.World;
import java.util.UUID;

public class TrackedPlayer {
    private final PlayerEntity entity;

    private final UUID uuid;
    private final String name;
    private RegistryKey<World> dimension;

    private double x;
    private double z;

    public TrackedPlayer(PlayerEntity player) {
        this.entity = player;

        this.uuid = player.getUuid();
        this.name = player.getName().getString();
        this.dimension = player.getWorld().getRegistryKey();
        this.x = player.getX();
        this.z = player.getZ();
    }

    public TrackedPlayer(UUID uuid, String name) {
        this.entity = null;

        this.uuid = uuid;
        this.name = name;
    }

    public PlayerEntity getEntity() {return entity;}

    public UUID getUuid() {return uuid;}

    public String getName() {return name;}

    public RegistryKey<World> getDimension() {return dimension;}

    public double getX() {return x;}

    public double getZ() {return z;}

    public void update() {
        if (entity != null) {
            x = entity.getX();
            z = entity.getZ();
        }
        else {
            // not implemented yet
            x = 0;
            z = 0;
        }
    }
}



package me.chorus.playerfinderhud;

import me.chorus.playerfinderhud.util.ModUtils;
import me.chorus.playerfinderhud.util.PlayerUtils;
import me.chorus.playerfinderhud.util.TrackedPlayer;
import net.fabricmc.fabric.api.client.event.lifecycle.v1.ClientTickEvents;
import net.fabricmc.fabric.api.client.rendering.v1.hud.HudElementRegistry;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.font.TextRenderer;
import net.minecraft.client.gl.RenderPipelines;
import net.minecraft.client.network.PlayerListEntry;
import net.minecraft.client.world.ClientWorld;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.text.Text;
import net.minecraft.util.Identifier;

public class CompassHUD {
    private static final double halfRange = 360.0 / (32 * 2);

    private static final Identifier COMPASS_404_ICON = Identifier.of(
            PlayerFinderHUD.MOD_ID,"textures/gui/compass_404.png"
    );
    private static MinecraftClient client = MinecraftClient.getInstance();
    private static ClientWorld world = client.world;

    private static PlayerEntity player = client.player;
    private static TrackedPlayer target = null; // by default

    private static int compassTexture = 404;

    private static final int NEARBY_UPDATE_INTERVAL = 5;
    private static final int REMOTE_UPDATE_INTERVAL = 40;

    private static long tickCounter = 0L;
    private static long lastUpdateTick = 0L;

    public static void register() {
        HudElementRegistry.addLast(
            COMPASS_404_ICON,
            // This method is called every tick to render the compass HUD
            (context, tickCounter) -> {

                if (client.options.hudHidden) return;

                if (world != MinecraftClient.getInstance().world
                        || player == null || target == null) {
                    updateClientReferences();
                }

                // Calculate which compass texture to use

                if (CompassHUD.tickCounter - lastUpdateTick >= getUpdateFrequency(target)) {
                    lastUpdateTick = CompassHUD.tickCounter;

                    Boolean withinRenderDistance = PlayerUtils.isWithinRenderDistance(target.getUuid());
                    if (withinRenderDistance == null) {
                        updateClientReferences();
                    } else if (withinRenderDistance && target.getEntity() == null
                                                    ||
                               !withinRenderDistance && target.getEntity() != null) {
                        setTargetPlayer(
                                client.getNetworkHandler().getPlayerListEntry(target.getUuid()),
                                target.getName(),
                                true
                        );
                    }

                    if (player.getWorld().getRegistryKey() == target.getDimension()) {

                        target.update();

                        int playerX = (int) player.getX();
                        int playerZ = (int) player.getZ();
                        int playerYaw = ((int) player.getYaw() % 360 + 360) % 360;

                        int targetX = (int) target.getX();
                        int targetZ = (int) target.getZ();

                        if ((playerX == targetX && playerZ == targetZ)
                                ||
                            player == target.getEntity()) {
                            compassTexture = 404;
                        }
                        else {
                            int targetYaw = ModUtils.calculateAngle(
                                    playerX, playerZ,
                                    targetX, targetZ
                            );

                            int angle = ((180 + (targetYaw - playerYaw)) % 360 + 360) % 360;

                            compassTexture = (int) ((angle + halfRange) / (2 * halfRange));
                            compassTexture %= 32;
                        }
                    }
                }

                Identifier COMPASS_ICON = Identifier.of(
                        PlayerFinderHUD.MOD_ID,
                        "textures/gui/compass_" + compassTexture + ".png"
                );

                // Draw the compass icon on the HUD

                final int compassX = 10, compassY = 10;
                final int compassU = 0, compassV = 0;
                final int maxSide = 64; // px
                int[] size = ModUtils.scaleTextureToFit(COMPASS_ICON, maxSide);

                int compassWidth = size[0];
                int compassHeight = size[1];

                context.drawTexture(
                    RenderPipelines.GUI_TEXTURED,
                    COMPASS_ICON,
                    compassX, compassY,
                    compassU, compassV,
                    compassWidth, compassHeight,
                    compassWidth, compassHeight
                );

                // Draw the target player's name below the compass

                TextRenderer tr = client.textRenderer;
                int textHeight = tr.fontHeight;

                String[] lines = {
                        "Tracking:",
                        target.getName()
                };

                for (int i = 0; i < lines.length; i++) {
                    String line = lines[i];
                    int textWidth = tr.getWidth(line);
                    int x = Math.max(0, compassX + (compassWidth - textWidth) / 2);
                    int y = compassY + compassHeight + i * textHeight;

                    context.drawText(tr, Text.literal(line),
                                     x, y, 0xFF00FF00,
                                     false);
                }
            }
        );

        ClientTickEvents.END_CLIENT_TICK.register(
        client -> {
                if (client.options.hudHidden) return;
                tickCounter++;
            }
        );
    }

    public static void setTargetPlayer(PlayerListEntry entry, String name, boolean resetOnError) {
        if (name == null) return;

        if (entry != null) {
            PlayerEntity playerEntity = PlayerUtils.getPlayerEntity(entry.getProfile().getId());
            if (playerEntity != null) {
                target = new TrackedPlayer(playerEntity);
            }
            else {
                PlayerUtils.playerOutOfRenderDistanceMessage(name);
                if (resetOnError) updateClientReferences();
            }
        }
        else {
            PlayerUtils.invalidPlayerMessage(name);
            if (resetOnError) updateClientReferences();
        }
    }

    private static void updateClientReferences() {
        boolean newWorld = world != MinecraftClient.getInstance().world;
        String targetName = (target != null) ? target.getName() : "target player";

        client = MinecraftClient.getInstance();
        world = client.world;
        player = client.player;

        assert player != null : "client.player is null";
        target = new TrackedPlayer(player);

        if (!newWorld) {
            PlayerUtils.invalidPlayerMessage(targetName);
        }
    }

    private static int getUpdateFrequency(TrackedPlayer player) {
        return (player.getEntity() != null) ? NEARBY_UPDATE_INTERVAL : REMOTE_UPDATE_INTERVAL;
    }
}



package me.chorus.playerfinderhud;

import me.chorus.playerfinderhud.mixin.ScreenInvoker;
import me.chorus.playerfinderhud.util.ModUtils;
import net.fabricmc.fabric.api.client.screen.v1.ScreenEvents;
import net.minecraft.client.gui.screen.GameMenuScreen;
import net.minecraft.util.Identifier;

public class GameMenuCompassButton {
    private static final Identifier ICON = Identifier.of(
            PlayerFinderHUD.MOD_ID,"textures/gui/compass_404.png");

    public static void register() {
        ScreenEvents.AFTER_INIT.register(
            (client, screen, scaledWidth, scaledHeight) -> {
                if (!(screen instanceof GameMenuScreen)) return;

                int[] buttonPos = ModUtils.getButtonPosition(
                        screen,
                        "menu.returnToGame"
                );

                int iconX = buttonPos[0] + buttonPos[2] + 6;
                int iconY = buttonPos[1];
                int iconWidth = buttonPos[3];
                int iconHeight = buttonPos[3];

                GameMenuScreen gameMenuScreen = new GameMenuScreen(true);

                IconButtonWidget openCompassSettings = new IconButtonWidget(
                        iconX, iconY,
                        iconWidth, iconHeight,
                        btn ->
                                client.setScreen(new ModSettingsScreen(gameMenuScreen)),
                        ICON
                );

                ((ScreenInvoker) screen).invokeAddDrawableChild(openCompassSettings);
            }
        );
    }
}



package me.chorus.playerfinderhud;

import net.minecraft.client.gl.RenderPipelines;
import net.minecraft.client.gui.DrawContext;
import net.minecraft.client.gui.widget.ButtonWidget;
import net.minecraft.text.Text;
import net.minecraft.util.Identifier;

public class IconButtonWidget extends ButtonWidget {
    private static Identifier ICON_TEXTURE;

    public IconButtonWidget(int x, int y, int width, int height,
                            PressAction onPress, Identifier id) {
        super(x, y, width, height, Text.empty(), onPress,
              DEFAULT_NARRATION_SUPPLIER);

        ICON_TEXTURE = id;
    }

    @Override
    public void renderWidget(DrawContext context, int mouseX, int mouseY, float delta) {
        super.renderWidget(context, mouseX, mouseY, delta);

        context.drawTexture(
                RenderPipelines.GUI_TEXTURED,
                ICON_TEXTURE,
                getX(), getY(),
                0f, 0f,
                getWidth(), getHeight(),
                getWidth(), getHeight()
        );
    }
}



package me.chorus.playerfinderhud;

import me.chorus.playerfinderhud.util.ModUtils;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.gui.screen.Screen;
import net.minecraft.client.gui.screen.option.OptionsScreen;
import net.minecraft.client.gui.widget.ButtonWidget;
import net.minecraft.client.network.PlayerListEntry;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.text.Text;

import java.util.Collection;

public class ModSettingsScreen extends Screen {
    private final Screen parent;
    private ScrollableList playerSelectorList;

    private final String suffix = " (You)";

    public ModSettingsScreen(Screen parent) {
        super(Text.literal("Track a player"));
        this.parent = parent;
    }

    @Override
    protected void init() {

        MinecraftClient client = MinecraftClient.getInstance();
        if (client.options.hudHidden || client.player == null)
            return;

        // Creating 'Done' button

        OptionsScreen optionsScreen = new OptionsScreen(
                client.currentScreen,
                client.options
        );

        optionsScreen.init(
                client,
                this.width,
                this.height
        );

        int[] donePos = ModUtils.getButtonPosition(
                optionsScreen,
                "gui.done"
        );

        ButtonWidget doneButton = ButtonWidget.builder(
                Text.translatable("gui.done"), btn -> closeScreen()
                )
                .dimensions(donePos[0], donePos[1],
                            donePos[2], donePos[3])
                .build();

        addDrawableChild(doneButton);

        // Creating scrollable list of players

        this.playerSelectorList = new ScrollableList(
                client, client.currentScreen,
                donePos[0], donePos[1] - 150,
                donePos[2], 100,
                10, 20,
                false
        );
        playerSelectorList.setVisible(true);

        PlayerEntity player = client.player;
        playerSelectorList.addEntry(player.getName().getString() + suffix);

        Collection<PlayerListEntry> players = client.getNetworkHandler().getPlayerList();

        for (PlayerListEntry entry : players) {
            // Skip the current player
            if (entry.getProfile().getId().equals(player.getUuid())) continue;

            String name = entry.getProfile().getName();
            playerSelectorList.addEntry(name);
        }
    }

    @Override
    public boolean keyPressed(int keyCode, int scanCode, int modifiers) {
        if (keyCode == 256) { // ESC key
            closeScreen();
            return true;
        }
        return super.keyPressed(keyCode, scanCode, modifiers);
    }

    private void closeScreen() {
        MinecraftClient client = MinecraftClient.getInstance();

        Integer index = playerSelectorList.getSelectedIndex(ScrollableList.ALL);
        String selectedPlayerName = (index != null) ? playerSelectorList.getEntry(index) : null;

        PlayerListEntry selectedPlayer = null;

        if (selectedPlayerName != null && selectedPlayerName.endsWith(suffix)) {
            selectedPlayerName = selectedPlayerName.replace(suffix, "");
            selectedPlayer = client.getNetworkHandler().
                    getPlayerListEntry(client.player.getUuid());
        }
        else if (selectedPlayerName != null) {
            for (PlayerListEntry player : client.getNetworkHandler().getPlayerList()) {
                if (player.getProfile().getName().equals(selectedPlayerName)) {
                    selectedPlayer = player;
                    break;
                }
            }
        }

        CompassHUD.setTargetPlayer(selectedPlayer, selectedPlayerName, false);

        client.setScreen(this.parent);
    }
}



package me.chorus.playerfinderhud;

import net.fabricmc.api.ModInitializer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class PlayerFinderHUD implements ModInitializer {
    public static final String MOD_ID = "playerfinderhud";
    public static final Logger LOGGER = LoggerFactory.getLogger(MOD_ID);

    @Override
    public void onInitialize() {
    }
}



package me.chorus.playerfinderhud;

import me.chorus.playerfinderhud.mixin.ScreenInvoker;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.gui.DrawContext;
import net.minecraft.client.gui.Drawable;
import net.minecraft.client.gui.Element;
import net.minecraft.client.gui.Selectable;
import net.minecraft.client.gui.screen.Screen;
import net.minecraft.client.gui.screen.narration.NarrationMessageBuilder;
import net.minecraft.client.gui.widget.TextFieldWidget;
import net.minecraft.client.util.InputUtil;
import net.minecraft.text.Text;
import org.lwjgl.glfw.GLFW;

import java.util.ArrayList;
import java.util.List;

public class ScrollableList implements Drawable, Element, Selectable {
    private final int x, y, width, height, itemHeight, totalItemHeight, entryHeight;
    private final int offset = 4;

    private boolean visible = false;

    private final TextFieldWidget searchField;
    private String filter = "";

    private final MinecraftClient client;
    private final Screen screen;

    private final List<String> allElements = new ArrayList<>();
    private final List<String> visibleElements = new ArrayList<>();

    private int selectedIndex = -1;

    public static String ALL = "all";
    public static String VISIBLE = "visible";

    private int scrollY = 0;
    private int scrollX = 0;
    private int maxScrollY = offset;
    private int maxScrollX = offset;

    // Implementation of abstract methods

    @Override
    public void setFocused(boolean focused) { }

    @Override
    public boolean isFocused() { return false; }

    @Override
    public SelectionType getType() { return SelectionType.NONE; }

    @Override
    public void appendNarrations(NarrationMessageBuilder builder) { }

    // Constructor method

    public ScrollableList(MinecraftClient client, Screen screen, int x, int y, int width, int height,
                          int itemHeight, int entryHeight, boolean isInside) {
        this.client = client;
        this.screen = screen;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = isInside ? height - entryHeight : height;
        this.itemHeight = itemHeight;
        this.totalItemHeight = this.itemHeight + this.offset;
        this.entryHeight = entryHeight;

        this.searchField = new TextFieldWidget(
                client.textRenderer,
                x, y - entryHeight,
                width, entryHeight,
                Text.literal("Search...")
        );
        this.searchField.setPlaceholder(Text.literal("Search..."));
        this.searchField.setChangedListener(this::refreshVisibleEntries);
    }

    //  Public method for showing and hiding the list

    /**
     * Visible = true: Shows Scrollable List.
     * Visible = false: Hides Scrollable List.
     * */
    public void setVisible(boolean visible) {
        if (this.visible == visible) return;

        if (visible) show();
        else hide();
    }

    private void show() {
        this.visible = true;

        ((ScreenInvoker) this.screen).invokeAddDrawableChild(this);
        ((ScreenInvoker) this.screen).invokeAddDrawableChild(this.searchField);
    }

    private void hide() {
        this.visible = false;

        this.searchField.setFocused(false);
        this.searchField.setText("");
        this.screen.children().remove(this);
        this.screen.children().remove(this.searchField);
    }

    // Setters and Getters

    public int[] getProperties() {
        return new int[]{this.x, this.y, this.width, this.height, this.itemHeight,
                         this.offset, this.totalItemHeight, this.entryHeight};
    }

    public boolean isVisible() {
        return this.visible;
    }

    public boolean isSelected() {
        return selectedIndex != -1;
    }

    public void addEntry(String text) {
        allElements.add(text);
        refreshVisibleEntries(this.filter);
    }

    public void addEntry(int index, String text) {
        allElements.add(index, text);
        refreshVisibleEntries(this.filter);
    }

    public void setEntry(int index, String newText) {
        allElements.set(index, newText);
        refreshVisibleEntries(this.filter);
    }

    public String getEntry(int index) {
        return allElements.get(index);
    }

    public String removeEntry(int index) {
        String removed = allElements.remove(index);
        refreshVisibleEntries(this.filter);
        return removed;
    }

    public Integer getSelectedIndex(String getFrom) {
        if (getFrom.equals(VISIBLE)) {
            return (selectedIndex != -1) ? this.selectedIndex : null;
        } else if (getFrom.equals(ALL)) {
            return (selectedIndex != -1) ? findInAll(this.selectedIndex) : null;
        } else {
            return null;
        }
    }

    public List<String> getAllElements() {
        return allElements;
    }

    public List<String> getVisibleElements() {
        return visibleElements;
    }

    // Render method. Called every frame

    @Override
    public void render(DrawContext context, int mouseX, int mouseY, float delta) {
        if (!this.visible) return;

        this.searchField.render(context, mouseX, mouseY, delta);

        context.fill(x, y, x + width, y + height, 0xAA000000);
        context.enableScissor(x, y, x + width, y + height);

        int visibleCount = height / totalItemHeight;
        int startIndex = (int) Math.round((double) scrollY / (double) totalItemHeight);

        for (int i = 0; (i < visibleCount) && (startIndex + i < visibleElements.size()); i++) {
            String text = visibleElements.get(startIndex + i);
            int color = (startIndex + i == selectedIndex && selectedIndex != -1)
                    ? 0xFF808080 : 0xFFFFFFFF;

            int drawX = offset + (x - scrollX);
            int drawY = offset + (y + i * totalItemHeight);

            context.drawText(client.textRenderer, text, drawX, drawY, color, false);
        }
    }

    // Mouse and keyboard event methods

    @Override
    public boolean mouseScrolled(double mouseX, double mouseY, double horizontalAmount, double verticalAmount) {
        if (!this.visible) return false;

        if (insideList(mouseX, mouseY)) {
            if (isShiftDown()) {
                scrollX -= (int) (verticalAmount * 5);
                scrollX = Math.min(maxScrollX, Math.max(0, scrollX));
            } else {
                scrollY -= (int) (verticalAmount * totalItemHeight);
                scrollY = Math.min(maxScrollY, Math.max(0, scrollY));
            }
        }

        return true;
    }

    @Override
    public boolean isMouseOver(double mouseX, double mouseY) {
        if (!this.visible) return false;

        return !insideEntry(mouseX, mouseY);
    }

    @Override
    public boolean mouseClicked(double mouseX, double mouseY, int button) {
        if (!this.visible) return false;

        boolean clickedInsideEntry = insideEntry(mouseX, mouseY);
        boolean clickedInsideList = insideList(mouseX, mouseY);

        if (!clickedInsideEntry && !clickedInsideList && searchField.isFocused()) {
            searchField.setFocused(false);
            searchField.setText("");
        }

        if (clickedInsideList){
            int previouslySelectedIndex = selectedIndex;
            selectedIndex = (int) Math.min(
                    Math.max(0, Math.floor((mouseY - y + scrollY) / totalItemHeight)),
                    visibleElements.size() - 1
            );
            if (selectedIndex == previouslySelectedIndex) selectedIndex = -1;
        }

        return clickedInsideEntry || clickedInsideList;
    }

    @Override
    public boolean charTyped(char chr, int modifiers) {
        if (!this.visible) return false;
        return searchField.charTyped(chr, modifiers);
    }

    @Override
    public boolean keyPressed(int keyCode, int scanCode, int modifiers) {
        if (!this.visible) return false;
        return searchField.keyPressed(keyCode, scanCode, modifiers);
    }

    // Private helper methods

    private boolean isShiftDown() {
        long window = MinecraftClient.getInstance().getWindow().getHandle();
        return InputUtil.isKeyPressed(window, GLFW.GLFW_KEY_LEFT_SHIFT)
                || InputUtil.isKeyPressed(window, GLFW.GLFW_KEY_RIGHT_SHIFT);
    }

    private void filterVisibleEntries(String filter) {
        visibleElements.clear();
        for (String element : allElements) {
            if (element.toLowerCase().contains(filter.toLowerCase())) {
                visibleElements.add(element);
            }
        }
    }

    private void refreshVisibleEntries(String filter) {
        this.filter = filter;
        filterVisibleEntries(this.filter);

        String widest = "";
        for (String entry : visibleElements) {
            if (client.textRenderer.getWidth(entry) >
                client.textRenderer.getWidth(widest)) {
                widest = entry;
            }
        }
        calculateScrollBounds(widest);

        scrollY = Math.min(maxScrollY, Math.max(0, scrollY));
        scrollX = Math.min(maxScrollX, Math.max(0, scrollX));
    }

    private void calculateScrollBounds(String text) {
        int contentHeight = visibleElements.size() * totalItemHeight;
        maxScrollY = Math.max(0, contentHeight - height);

        int elementWidth = client.textRenderer.getWidth(text) + 2 * offset;
        maxScrollX = Math.max(0, elementWidth - width);
    }

    private boolean insideEntry(double mouseX, double mouseY) {
        return mouseX >= x && mouseX <= x + width &&
               mouseY >= y - entryHeight && mouseY <= y;
    }

    private boolean insideList(double mouseX, double mouseY) {
        return mouseX >= x && mouseX <= x + width &&
               mouseY >= y && mouseY <= y + height;
    }

    private int findInAll(int indexInVisible) {
        return allElements.indexOf(visibleElements.get(indexInVisible));
    }
}












//package me.chorus.simpletrackingcompass;
//
//import me.chorus.simpletrackingcompass.util.ModUtils;
//import me.chorus.simpletrackingcompass.util.PlayerUtils;
//import me.chorus.simpletrackingcompass.util.TrackedPlayer;
//import net.fabricmc.fabric.api.client.event.lifecycle.v1.ClientTickEvents;
//import net.fabricmc.fabric.api.client.rendering.v1.hud.HudElementRegistry;
//import net.minecraft.client.MinecraftClient;
//import net.minecraft.client.font.TextRenderer;
//import net.minecraft.client.gl.RenderPipelines;
//import net.minecraft.client.world.ClientWorld;
//import net.minecraft.entity.player.PlayerEntity;
//import net.minecraft.text.Text;
//import net.minecraft.util.Identifier;
//
//import java.util.UUID;
//
//import static me.chorus.simpletrackingcompass.SimpleTrackingCompass.MOD_ID;
//
//public class CompassHUD {
//
//    // Client references
//
//    private static MinecraftClient client = MinecraftClient.getInstance();
//    private static ClientWorld world = client.world;
//    private static PlayerEntity player = client.player;
//
//    // Target player being tracked
//
//    private static TrackedPlayer target = null; // by default
//
//    private static boolean targetConfirmed = true;
//    private static Object[] previousTargetProperties = new Object[3];
//
//    // Compass related variables
//
//    private static final Identifier COMPASS_404_ICON = Identifier.of(
//            MOD_ID,"textures/gui/compass_404.png"
//    );
//
//    private static int compassTexture = 404;
//
//    private static final double halfRange = 360.0 / (32 * 2);
//
//    // Timing variables
//
//    // TODO: Make these adjustable by the client
//    private static final int NEARBY_UPDATE_INTERVAL = 5;
//    private static final int REMOTE_UPDATE_INTERVAL = 5;
//
//    private static long tickCounter = 0L;
//    private static long lastUpdateTick = 0L;
//
//    // Fallback coordinates
//
//    private static double fallbackX = 0;
//    private static double fallbackZ = 0;
//
//    // Public booleans
//
//    public static boolean CompassHUDHidden = false;
//    public static boolean IsServerModded = false;
//
//    public static void register() {
//        HudElementRegistry.addLast(
//            COMPASS_404_ICON,
//            // This method is called every tick to render the compass HUD
//            (context, _) -> {
//
//                if (isHidden()) return;
//
//                if (client == null || world == null || player == null) updateClientReferences();
//                if (target == null) updateTrackedPlayer();
//
//                // Calculate which compass texture to use
//
//                if (CompassHUD.tickCounter - lastUpdateTick >= getUpdateFrequency()) {
//                    lastUpdateTick = CompassHUD.tickCounter;
//
//                    updateClientReferences();
//                    updateTrackedPlayer();
//
//                    int playerX = (int) player.getX();
//                    int playerZ = (int) player.getZ();
//
//                    int targetX = (int) getSafeX(target);
//                    int targetZ = (int) getSafeZ(target);
//
//                    if ((playerX == targetX && playerZ == targetZ)
//                            ||
//                        player.getUuid() == target.getUuid()) {
//                        compassTexture = 404;
//                    }
//                    else {
//                        int playerYaw = ((int) player.getYaw() % 360 + 360) % 360;
//
//                        int targetYaw = ModUtils.calculateAngle(
//                                playerX, playerZ,
//                                targetX, targetZ
//                        );
//
//                        int angle = ((180 + (targetYaw - playerYaw)) % 360 + 360) % 360;
//
//                        compassTexture = (int) ((angle + halfRange) / (2 * halfRange));
//                        compassTexture %= 32;
//                    }
//                }
//
//                Identifier COMPASS_ICON = Identifier.of(
//                        MOD_ID,
//                        "textures/gui/compass_" + compassTexture + ".png"
//                );
//
//                // Draw the compass icon on the HUD
//
//                final int compassX = 10, compassY = 10;
//                final int compassU = 0, compassV = 0;
//                final int maxSide = 64; // px
//                int[] size = ModUtils.scaleTextureToFit(COMPASS_ICON, maxSide);
//
//                int compassWidth = size[0];
//                int compassHeight = size[1];
//
//                context.drawTexture(
//                    RenderPipelines.GUI_TEXTURED,
//                    COMPASS_ICON,
//                    compassX, compassY,
//                    compassU, compassV,
//                    compassWidth, compassHeight,
//                    compassWidth, compassHeight
//                );
//
//                // Draw the target player's name below the compass
//
//                TextRenderer tr = client.textRenderer;
//                int textHeight = tr.fontHeight;
//
//                String[] lines = {
//                        "Tracking:",
//                        target.getName()
//                };
//
//                for (int i = 0; i < lines.length; i++) {
//                    String line = lines[i];
//                    int textWidth = tr.getWidth(line);
//                    int x = Math.max(0, compassX + (compassWidth - textWidth) / 2);
//                    int y = compassY + compassHeight + i * textHeight;
//
//                    context.drawText(tr, Text.literal(line),
//                                     x, y, 0xFF00FF00,
//                                     false);
//                }
//            }
//        );
//
//        ClientTickEvents.END_CLIENT_TICK.register(
//                _ -> {
//                if (isHidden()) return;
//                tickCounter++;
//            }
//        );
//    }
//
//    public static void setTargetPlayer(UUID uuid, String name, boolean runtimeTriggered) {
//        if (name == null) return;
//
//        if (uuid != null) {
//            PlayerEntity playerEntity = PlayerUtils.getPlayerEntity(uuid);
//            previousTargetProperties = new Object[]{target.getUuid(), target.getName(), null};
//
//            if (playerEntity != null) {
//                player.sendMessage(Text.literal("<setTargetPlayer> Nearby"), false);
//                target = new TrackedPlayer(playerEntity);
//                targetConfirmed = true;
//            }
//            else if (IsServerModded) {
//                player.sendMessage(Text.literal("<setTargetPlayer> Remote"), false);
//                if (runtimeTriggered) previousTargetProperties[2] = target.getDimension();
//
//                target = new TrackedPlayer(uuid, name);
//                targetConfirmed = runtimeTriggered;
//            }
//            else {
//                player.sendMessage(Text.literal("<setTargetPlayer> Distance Error!"), false);
//                if (runtimeTriggered) resetTarget();
//                PlayerUtils.playerOutOfRenderDistanceWarn(name);
//            }
//        }
//        else {
//            player.sendMessage(Text.literal("<setTargetPlayer> Player Error!"), false);
//            if (runtimeTriggered) resetTarget();
//            PlayerUtils.playerNotFoundError(name);
//        }
//
//        resetTickCounter();
//        tickCounter += getUpdateFrequency();
//    }
//
//    public static boolean isHidden() {
//        return CompassHUDHidden || MinecraftClient.getInstance().options.hudHidden;
//    }
//
//    public static TrackedPlayer getTarget() {
//        return target;
//    }
//
//    public static void onJoin() {
//        updateClientReferences();
//        resetTarget();
//        resetTickCounter();
//    }
//
//    // Private helper methods
//
//    private static double getSafeX(TrackedPlayer player) {
//        return player.hasPositionBeenEverChanged() ? player.getX() : fallbackX;
//    }
//
//    private static double getSafeZ(TrackedPlayer player) {
//        return player.hasPositionBeenEverChanged() ? player.getZ() : fallbackZ;
//    }
//
//    private static int getUpdateFrequency() {
//        return (target != null && target.getEntity() != null) ? NEARBY_UPDATE_INTERVAL : REMOTE_UPDATE_INTERVAL;
//    }
//
//    private static void resetTickCounter() {
//        tickCounter = 0L;
//        lastUpdateTick = 0L;
//    }
//
//    private static void resetTarget() {
//        target = MinecraftClient.getInstance().player != null ? new TrackedPlayer(MinecraftClient.getInstance().player) : null;
//    }
//
//    private static void updateClientReferences() {
//        client = MinecraftClient.getInstance();
//        world = client.world;
//        player = client.player;
//    }
//
//    private static void updateTrackedPlayer() {
//        if (target == null) resetTarget();
//
//        Identifier playerDim = world.getRegistryKey().getValue();
//        Identifier targetDim = target.getDimension();
//
//        Identifier previousTargetDim = (Identifier) previousTargetProperties[2];
//        if (previousTargetDim != null) {
//            if (targetDim != null) {
//                if (previousTargetDim.equals(targetDim) && !playerDim.equals(targetDim)) {
//                    PlayerUtils.playerInAnotherDimensionWarn(target != null ? target.getName() : "Target Player", targetDim);
//                    resetTarget();
//                }
//                previousTargetProperties[2] = null;
//            }
//            return;
//        }
//
//        if (!targetConfirmed) {
//            if (targetDim != null) {
//                if (playerDim.equals(targetDim)) {
//                    targetConfirmed = true;
//                }
//                else {
//                    PlayerUtils.playerInAnotherDimensionWarn(target != null ? target.getName() : "Target Player", targetDim);
//                    setTargetPlayer((UUID) previousTargetProperties[0], (String) previousTargetProperties[1], true);
//                }
//            }
//            return;
//        }
//
//        Boolean withinRenderDistance = PlayerUtils.isWithinRenderDistance(target.getUuid());
//        if (withinRenderDistance == null) {
//            PlayerUtils.playerNotFoundError(target != null ? target.getName() : "Target Player");
//            resetTarget();
//        } else if ((withinRenderDistance && target.getEntity() == null) || (!withinRenderDistance && target.getEntity() != null)) {
//            player.sendMessage(Text.literal("<updateTrackedPlayer> " + withinRenderDistance + ", " + target.getEntity()), false);
//            setTargetPlayer(
//                    target.getUuid(),
//                    target.getName(),
//                    true
//            );
//        }
//
//        target.update();
//
//        if (target.hasPositionBeenEverChanged()) {
//            fallbackX = target.getX();
//            fallbackZ = target.getZ();
//        }
//    }
//}